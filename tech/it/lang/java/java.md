[TOC]

# Overview

## Introduction

- Goal: write once, run everywhere (WORA)
- Java applications are typically compiled to bytecode (class file) that
  can run on any Java Virtual Machine (JVM) regardless of computer
  architecture.
- https://www.win.tue.nl/~evink/education/avp/pdf/feel-of-java.pdf

## Principles

There were five primary goals in the creation of the Java language:

1. It should be **simple, object-oriented and familiar**
2. It should be **robust and secure**
3. It should be **architecture-neutral and portable**
4. It should execute with **high performance**
5. It should be **interpreted, threaded, and dynamic**

## Resources

- Oracle Java Tutorials
    + https://docs.oracle.com/javase/tutorial/index.html (all tutorials)
    + https://docs.oracle.com/javase/tutorial/java/TOC.html
    + https://docs.oracle.com/javase/tutorial/essential/index.html
    + https://docs.oracle.com/javase/tutorial/extra/generics/index.html
- Other tutorials
    + https://howtodoinjava.com/series/java-tutorial/
    + Jenkov's tutorials
        * https://jenkov.com/tutorials/java/index.html
- Books
    + Something
- Specifications (Java Specs)
    + https://docs.oracle.com/javase/specs/index.html
    + Java/Jakarta EE:
        * Java EE 8: https://www.oracle.com/java/technologies/java-ee-8.html
        * Jakarta EE: https://jakarta.ee/specifications/
    + Java SE: https://docs.oracle.com/javase/specs/
- Java/Jakarta EE Web technologies
    + https://en.wikipedia.org/wiki/Jakarta_EE#Web_profile

# Platform

## Introduction

- **Standardized libraries** provide a generic way to access
  host-specific features such as *graphics*, *threading*, and
  *networking*.

Each platform includes:
- Java compiler: Java source code to Java bytecode
- Java Virtual Machine (JVM): Java bytecode to machine code
  (interpreter)
- The libraries (API)

Main platforms:
- [Java Card](http://en.wikipedia.org/wiki/Java_Card): A technology that
  allows small Java-based applications (*applets*) to be run securely on
  smart cards and similar small-memory devices.
- [Java ME](http://www.oracle.com/technetwork/java/javame/index.html)
  (Micro Edition): Specifies several different sets of libraries (known
  as profiles) for devices with limited storage, display, and power
  capacities. Often used to develop applications for *mobile devices,
  PDAs, TV set-top boxes, and printers*.
- [Java SE](http://www.oracle.com/technetwork/java/javase/index.html)
  (Standard Edition): For *general-purpose* use on desktop PCs, servers
  and similar devices.
- [Java EE](http://www.oracle.com/technetwork/java/javaee/index.html)
  (Enterprise Edition): Java SE plus various APIs useful for *multi-tier
  client–server enterprise applications*.

## Implementations

The Oracle implementation is packaged into two different distributions:
- https://howtodoinjava.com/java/basics/jdk-jre-jvm/

- **The Java Runtime Environment** (JRE) which contains the parts of the
  Java SE platform required to run Java programs and is intended for
  end-users.
    + Including Java Virtual Machine (JVM) and Libraries
- **The Java Development Kit** (JDK), which is intended for software
  developers and includes development tools such as the [Java
  compiler](http://en.wikipedia.org/wiki/Java_compiler),
  [Javadoc](http://en.wikipedia.org/wiki/Javadoc),
  [Jar](http://en.wikipedia.org/wiki/JAR_(file_format)), and a
  **debugger**.
    + Including JRE and Development Tools

[OpenJDK](http://en.wikipedia.org/wiki/OpenJDK) is another notable Java
SE implementation that is licensed under the GPL. The implementation
started when Sun began releasing the Java source code under the GPL. As
of Java SE 7, OpenJDK is the official Java reference implementation.

## Java Bytecode

Java bytecode is the [instruction
set](http://en.wikipedia.org/wiki/Instruction_set) of the [Java virtual
machine](http://en.wikipedia.org/wiki/Java_virtual_machine).

Each bytecode is composed by one, or in some cases two, bytes that
represent the instruction
([opcode](http://en.wikipedia.org/wiki/Opcode)), along with zero or more
bytes for passing parameters. Of the 256 possible byte-long opcodes, 198
are currently in use, 51 are reserved for future use, and 3 are set
aside as permanently unimplemented.

"Understanding bytecode and what bytecode is likely to be generated by a
Java compiler helps the Java programmer in the same way that knowledge
of assembly helps the C or C++ programmer."

## Java Virtual Machine ([JVM](http://en.wikipedia.org/wiki/Java_virtual_machine))

A **Java virtual machine** (JVM) is a [process virtual machine](http://e
n.wikipedia.org/wiki/Virtual_machine#Process_virtual_machines) that can
execute [Java bytecode](http://en.wikipedia.org/wiki/Java_bytecode). It
is the code execution component of the [Java
platform](http://en.wikipedia.org/wiki/Java_platform).

JVMs use [JIT](http://en.wikipedia.org/wiki/Just-in-time_compilation)
compiling, not interpreting, to achieve greater speed.

![JVM architecture](https://upload.wikimedia.org/wikipedia/commons/d/dd/JvmSpec7.png)

## Java Runtime Environment ([JRE](http://www.java.com/))

JRE = JIT compiler + JVM

Java Bytecode -> JRE -> Machine code

## Java Standard Edition ([Java SE](http://www.oracle.com/technetwork/java/javase/index.html))

- Java Platform, Standard Edition or Java SE is a widely used platform
  for development and deployment of portable applications for desktop
  and server environments.
- Strictly speaking, Java SE is a platform specification. It defines a
  wide range of general purpose APIs—such as Java APIs for the Java
  Class Library[citation needed]—and also includes the Java Language
  Specification and the Java Virtual Machine Specification.

## Java Enterprise Edition ([Java EE](http://www.oracle.com/technetwork/java/javaee/index.html))

- The platform provides an API and runtime environment for developing
  and running enterprise software, including network and web services,
  and other large-scale, multi-tiered, scalable, reliable, and secure
  network applications.
- Java EE extends the Java Platform, Standard Edition (Java SE),
  providing an API for object-relational mapping, distributed and
  multi-tier architectures, and web services.
- The platform incorporates a design based largely on modular components
  running on an application server. The platform emphasizes Convention
  over configuration and annotations for configuration.
- Optionally XML can be used to override annotations or to deviate from
  the platform defaults.

## Java Embedded

### Java Micro Edition ([Java ME](http://www.oracle.com/technetwork/java/javame/index.html))

Java Platform, Micro Edition, or Java ME, is a Java platform designed
for embedded systems (mobile devices are one kind of such systems).
Target devices range from industrial controls to mobile phones
(especially feature phones) and set-top boxes. Java ME was formerly
known as Java 2 Platform, Micro Edition (J2ME).

### [Java Card](http://en.wikipedia.org/wiki/Java_Card)

Java Card refers to a software technology that allows Java-based
applications (applets) to be run securely on smart cards and similar
small memory footprint devices. Java Card is the tiniest of Java
platforms targeted for embedded devices. Java Card gives the user the
ability to program the devices and make them application specific. It is
widely used in SIM cards (used in GSM mobile phones) and ATM cards.

# Practices

## Java Coding Style Guidelines

### Tools to automatically format code (linter, etc.)

- Checkstyle
    + https://checkstyle.sourceforge.io/
- https://github.com/diffplug/spotless
    + Using Gradle instead of Ant
- https://github.com/google/google-java-format
- https://docs.openrewrite.org/tutorials/automatically-fix-checkstyle-violations
- https://github.com/notzippy/JALOPY2-MAIN


### Naming Conventions

- Naming Rules for identifiers
    + Can be any unlimited-length sequence of Unicode letters and digits
      (only letters and digits not special characters such as `&`),
      beginning with a letter, or the dollar sign `$`, or the underscore
      character `_`.
    + It does not have the same spelling as preserved/key words

#### Package Names

- All packages should be in the form: `com.domain.department.project`
- All is lowercase
- In one level, if it is multiple words, these words should run together
  with no separating space or other character `(-, _).`
    + GOOD: `com.nasa.jpl.userinterface` or `com.nasa.jpl.ui`
    + BAD: `com.nasa.jpl.user_interface`

#### Class and Interface Names

- Class names are always nouns, not verbs.
    + Avoid making a noun out of a verb, e.g. Divider
    + If you are having difficulty naming a class then perhaps it is a
      bad class.
- Interface names should always be an adjective (wherever possible)
  describing the enforced behaviors of the class (noun).
    + Preferably, said adjective should end in "able"
    + Clonable, Versionable, Taggable, etc.
- Class and interface names begin with an uppercase letter and camel
  case form, and should not be pluralized unless it is a collection
  class.
    + GOOD: `class FoodItem`, `interface Digestable`
    + BAD: `class fooditem`, `class Crackers`, `interface Eat`
- Naming collection classes (in the generic sense of collection)
    + If you are a collection type as part of the class name (List, Map,
      etc.) it is not necessary to use the plural form in the class
      name.
    + If you are not using the collection type in the name it is
      necessary to pluralize the name.
    + If you are extending one of the Java collection class (Map,
      HashMap, List, ArrayList, Collection, etc.) it is good practice to
      use the name of the collection type in the class name.
    + GOOD: `class FoodItems extends Object`
    + GOOD: `class FoodItemList extends ArrayList`
    + GOOD: `class FoodItemMap extends HashMap`
    + BAD: `class FoodItem extends ArrayList`
    + BAD: `class FoodItemsList extends ArrayList`
- Class names should be descriptive in nature without implying
  implementation.
    + GOOD: `AbstractManagedPanel`, `LayeredPanel`
    + BAD: `LayeredPanel`
- Other than prefixes, no abbreviations should be used unless it is a
  well known abbreviation.
- File name = Class name
- `List`, `Truck`: interface for the "conceptual" object, a contract on
  what the public methods and properties have to support, a Type
- `AbstractList`, `AbstractTruck`: abstract "partial" implementation to
  assist custom implementations
- `ArrayList`, `LinkedList`, `DumpTruck`, `TransferTruck`: concrete
  implementation of interface

#### Method Names

- Method names are typically verbs. However they can also be nouns, for
  example, accessor methods.
- Names should reflect exactly what the method does (no more or no less)
    + A method should only have a single-purpose. If your method
      contains too much functionality, then you should break it into
      more than one method.
    + Strive for names that promote self documenting code.
        * The method name should read well in the code
        * Picture how the method will appear in your code
- Method names begin with a lowercase letter and in camel case form
    + Don't use underscores to separate words
- Method names should be defined so as to describe the function of the
  method without implying implementation.
    + GOOD: `addItem()`, `getItem()`
    + BAD: `addItemToVector()`, `getHashItem()`

#### Attribute and Local Variable Names

- Do not use abbreviations, use full names
    + Variable names begin with a lowercase letter
    + Clarity of variable names can be increased by providing some
      indication of the type of class they might become.
        * `Item menuItem`, `JPanel managerJPanel`
    + Attributes that are not collections should not be pluralized.
    + Collection classes, such as vectors and hashes should always be
      pluralized.
        * `Vector menuItems`, `Vector menuItemsVector`
- Name variables with the most abstract class that they can hold
    + If `startButton` could be any control object, then it should be
      named a `startControl`
- If the variable represents an anonymous object but is restricted by an
  interface, then including the interface name in the variable can
  increase clarity. (i.e. `clonableInventoryItem`)
- Declare each variable separately on a single line. Do not comma
  separate variables of the same type.
- CONSTANT VALUES should have uppercase letters for each word and each
  word should be separated by an underscore.
    + `public final static int MAX_AGE = 100`

#### Returning Arrays and Lists

- Any method that will returns an list of homogeneous or heterogeneous
  items should return a Collection (of other collection class) object -
  never an array.
    + For example, a method that return a list of keys represented as
      strings.
    + GOOD: `List getKeys()`
    + BAD: `String[] getKeys()`
- Also, any method that returns a Collection should always return a
  valid Collection - never null. However, the returned Collection can be
  empty

```java
// GOOD
public ArrayList getKeys() {
   if (0 == this.numValidKeys) {
      return new ArrayList();
   }
   return myKeyList;
}


// BAD
public ArrayList getKeys() {
   if (0 == this.numValidKeys) {
      return null;
   }
   return myKeyList;
}
```

#### Don't "HIDE" Names

- Name hiding refers to the practice of naming a local variable,
  argument, or filed the same (or similar) as that of another of greater
  scope.
    + For example, if you have a class attribute called `firstName` do
      not create a local variable called `firstName` or anything close
      to it, such as `firstNames` or `fName`

#### Numeric literals

- Underscores in numeric literals
    + https://docs.oracle.com/javase/8/docs/technotes/guides/language/underscores-literals.html
- In Java SE 7 and later, any number of underscore characters (_) can
  appear anywhere between digits in a numerical literal.

### Usage Conventions

#### Class Attributes

Class attributes should always be accessed through accessors and
mutators (getters and setters)

#### Modifier Usage

- Always use "public", "private", and "protected" keywords
- Class Attributes should be private. Access through public or protected
  getters and setters
- Methods in the public interface of a class should be public
- Other methods should be declared as protected

#### Class and Package Imports

- To make for more readable code, types used in code should be imported
  rather than fully qualifying the class name.
- Import only those classes necessary, not using `*`
- Import a package will import all classes and interfaces in that
  packages excluding sub-packages
    + You need to import sub-packages separately

#### Methods

- Methods in well-designed object-oriented code are short.
    + Strive to keep methods less than 10 lines.
    + Reconsider methods that are over a page in length, breaking them
      into several methods representing smaller blocks of functionality.
- This promote code reuse and allows for more combinations of methods.
- If the number of methods grows to be difficult to understand, then
  look at decomposing the class into more than one class.
- A good rule of thumb is that a method should be no more than screen in
  length.
- Follow the 30-second rule. Another programmer should be able to look
  at your method and fully understand what it does, why it does it, and
  how it does it in less than 30-seconds.

#### Keep It Simple

- Avoid nesting blocks of statements more than 2 or 3 levels deep
- Avoid nesting method calls too deeply
- Avoid using compound predicates:
    + `if (x>0 && x<100 && y>0 && y<100 || z==1000)`

#### Place Constants on Left Side of Expressions

- Avoid compiling the wrong code since assigning to constant is compiled
  error, so easy to detect the error

#### Optimization vs Abstraction

- Code in two pass mode
- First, implement with good object-oriented abstractions and well
  thought out design
- Second, when integrating your class into application, measure
  performance and seek out the bottlenecks. Then optimize the
  bottlenecks

## Documentation

Using javadoc utility:

## Testing and Unit Tests

### Testing Philosophy

- https://dagger.dev/hilt/testing-philosophy
    + Using fakes as much as possible for
      functional/integration/end-to-end testing (also for unit testing
      if it's possible or easy to do so)
- Throw exceptions in tests rather than handle them
    + https://stackoverflow.com/questions/31423643/try-catch-in-a-junit-test
- Use dependency injection more to make testing easier
    + Refactor source code if it's needed
- Use `@VisibleForTesting` and package scope to test methods if it's
  needed
    + Convert private methods to package scope (no access modifier), and
      then add `@VisibleForTesting`
    + Put the test class in the same package as the source class (use
      `package ...` on top of the class)

### Naming Conventions for Unit Tests

- Follow the convention for naming tests:
  `{methodBeingTested}_{scenario}_{expected-result}`
    + For happy case tests, you can omit `{scenario}`.

```
MethodName_StateUnderTest_ExpectedBehavior
cons: should be renamed if method change name
example: isAdult_AgeLessThan18_False

MethodName_ExpectedBehavior_StateUnderTest
cons: should be renamed if method change name
example: isAdult_False_AgeLessThan18

testFeatureBeingTested
cons: “test” prefix is redundant
example: testIsNotAnAdultIfAgeLessThan18

FeatureToBeTested
cons: no clue what result is expected from name
example: IsNotAnAdultIfAgeLessThan18

Should_ExpectedBehavior_When_StateUnderTest
cons: duplicates `should` and `when`, long name
example: Should_ThrowException_When_AgeLessThan18

When_StateUnderTest_Expect_ExpectedBehavior
cons: duplicates `when` and `expect`
example: When_AgeLessThan18_Expect_isAdultAsFalse

Given_Preconditions_When_StateUnderTest_Then_ExpectedBehavior — Behavior-Driven Development (BDD)
cons: duplicates `given`, `when`, `then`; really long names
example: Given_UserIsAuthenticated_When_InvalidAccountNumberIsUsedToWithdrawMoney_Then_TransactionsWillFail
```

### Environment Variables

- https://www.baeldung.com/java-unit-testing-environment-variables
- System stubs
    + https://www.baeldung.com/java-system-stubs
- Setting environment variables with libraries
    + https://stackoverflow.com/a/35393623/1683888
- https://stackoverflow.com/questions/318239/how-do-i-set-environment-variables-from-java/496849#496849
- https://stackoverflow.com/questions/8168884/how-to-test-code-dependent-on-environment-variables-using-junit

### Test Doubles

- https://testing.googleblog.com/2013/07/testing-on-toilet-know-your-test-doubles.html
- A test double is an object that can stand in for a real object in a test.
- Stubs, Mocks, and Fakes
    + A stub has no logic, and only returns what you tell it to return
    + A mock has expectations about the way it should be called, and a
      test should fail if it’s not called that way.
    + A fake doesn’t use a mocking framework: it’s a lightweight
      implementation of an API that behaves like the real
      implementation, but isn't suitable for production (e.g. an
      in-memory database).
- Should use fake as much as possible, then mocks, and finally stubs

## Serialization and Deserialization

- In memory (RAM), objects are represented as pointers to other places,
  and some special characteristics for speeding up computation. When we
  want to store or transfer objects, we need another representation of
  the objects that can be understood by other machines in the
  network. Serialization and deserialization are processes to convert
  the objects between these two representations.
    + Can be: JSON, XML, binary encoded.
- https://www.baeldung.com/java-serialization
- https://www.baeldung.com/java-serialization-approaches
- https://stackoverflow.com/questions/14011467/java-serialization-alternative-with-better-performance
- Some benchmarks for serialization schemes
    + https://w.amazon.com/bin/view/Siddartha_Naidu/Reports/SerializationPerf/
    + ION and Gzip is both compact and fast
- Some considerations to choose types of serialization
    + https://sage.amazon.com/questions/166777#166840
    + JSON or Ion: human-readable
    + Binary, Java-only format if no humans or long-time storing
- Fast serialization
- Custom serializer / deserializer
    + https://www.baeldung.com/jackson-deserialization
    + https://stackoverflow.com/questions/19158345/custom-json-deserialization-with-jackson
- Serialization and deserialization can be used for deep copy objects
    + https://www.baeldung.com/java-deep-copy

### Java Serialization API

- https://www.oracle.com/technical-resources/articles/java/serializationapi.html
- https://howtodoinjava.com/java/serialization/
- Best practices
    + https://stackoverflow.com/a/14946099
    + https://stackoverflow.com/a/3288280

### Define `serialVersionUID` when implementing Serializable interface

+ https://stackoverflow.com/questions/285793/what-is-a-serialversionuid-and-why-should-i-use-it
+ https://stackoverflow.com/questions/605828/does-it-matter-what-i-choose-for-serialversionuid-when-extending-serializable-cla
+ A number to specify the version of a serializable class.
+ You should explicitly set a number for this, e.g., `1L`
    * This will help to gain some performance since JVM does not need to
      perform runtime computation to find this value for the class.
    * This also help with prevent `InvalidClassException` due to
      different implementation of the compiler.
    * DO NOT CHANGE THIS VALUE!!!
    * DO NOT MAKE INCOMPATIBLE CHANGES: like changing types
        - https://docs.oracle.com/en/java/javase/21/docs/specs/serialization/version.html#type-changes-affecting-serialization
        - https://docs.oracle.com/javase/6/docs/platform/serialization/spec/version.html#5172

## Getter, Setter and Accessor

- https://dzone.com/articles/getter-setter-use-or-not-use-0

# Language Basics

## Loop

- while, do while, for

```java
// This for each loop cannot modify the array
// Use this for each loop to traverse the data
for (double element : values)
{
    sum = sum + element;
}
```

## Java API

The Java API is a collection of classes and interfaces that have been
written for you to use.
- Once you locate the package you want to use, you need to import it
into your code.

## Variables

- Initial Values of Variables
    + https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.12.5
    + https://docs.oracle.com/javase/specs/jls/se22/html/jls-4.html#jls-4.12.5

### Local variables

A local variables is a variable that is declared in the body of a
method.
- Parameter variables are similar to local variables, but they are
  declared in method headers.
- Local and parameter variables belong to methods. When a method runs,
  its local and parameter variables come to life. When the method exits,
  they are removed immediately.
- In contrast, instance variables belong to objects, not methods. When
  an object is constructed, its instance variables are created. The
  instance variables stay alive until no method uses the object any
  longer. (The Java virtual machine contains an garbage collector that
  periodically reclaims objects when  they are no longer used.)
- You must initialize all local variables
- Instance variables are initialized with a default value before a
  constructor is invoked.

## static

When you declare a variable or a method as static, it belongs to the
class, rather than to a specific instance.
- This means that only one instance of a static member exists, even if
  you create multiple objects of the class, or if you don't create any.
  It will be shared by all objects.
- It's a common practice to use upper case when naming a static
  variable, although not mandatory.

## final

Use the final keyword to mark a variable constant, so that it can be
assigned only once.
- Methods and classes can also be marked final.
    + So the methods can't be overridden.
    + And the classes can't be made subclasses.

## Packages

Packages are used to avoid name conflicts and to control access to
classes.
- A package can be defined as a group made up of similar types of
  classes, along with sub-packages.
- The following code will appear at the top of the classes:
    + `package <pkg_name>;`
- Import the classes
    + `import pkg.Vehicle;`
    + `import pkg.*`
- Two major results occur when a class is placed in a package.
    + First, the name of the package becomes a part of the name of the
      class.
    + Second, the name of the package must match the directory structure
      where the corresponding class file resides.

## Exception Handling

- Resources
    + Unchecked Exceptions - The Controversy
        * https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html
        * As a provider/server: If a client can reasonably be expected
          to recover from an exception, make it a checked exception. If
          a client cannot do anything to recover from the exception,
          make it an unchecked exception.
    + Checked exceptions (Have to handle these exceptions explicitly)
        * https://stackoverflow.com/questions/613954/the-case-against-checked-exceptions
        * A tool for API design
        * A different return mechanism for APIs
        * Using it sparingly, and only when you have some actions to
          recover the exception state.
        * Users have to handle these exception explicitly which can be
          annoyed, and many people are trying to remove this restriction
          by throwing only Unchecked exceptions or by using Lombok's
          SneakyThrows:
            - https://projectlombok.org/features/SneakyThrows

### Introduction

A `try` and `catch` block is placed around the code that might generate
an exception.

```java
try {
    //some code
} catch (Exception e) {
    //some code to handle errors
}
```

- Keywords
    + `throw`
    + `throws`
    + `try-catch`
    + `finally`

### Reading Exception Reports

1. The name of the exception, such as `StringIndexOutOfBoundsException`
2. The line number of the code that contained the statement that caused
   the exception, such as `Homework1.java:16`

The name of the exception is always in the first line of the report, and
it ends with `Exception`
- The first line of the stack trace is the method that actually
  generated the exception.
- THe last line of the stack trace is a line in `main`
- Often, the exception was thrown by a method that is in the standard
  library. Look for the first line in **your code** that appears in the
  exception report.


### `throw` keyword

The `throw` keyword allows you to manually generate exceptions from your
methods.

```java
int div(int a, int b) throws ArithmeticException {
    if (b == 0) {
        throw new ArithmeticException("Division by Zero");
    } else {
        return a/b;
    }
}
```

The `throws` statement in the method definition defines the type of
Exception(s) the method can throw.
- Next, the `throw` keyword throws the corresponding exception, along
  with a custom message.
- Multiple exceptions can be defined in the throws statement using a
  comma-separated list.

A single try block can contain multiple catch blocks that handle
different exceptions separately.
- All catch blocks should be ordered from most specific to most general.
- You can use the `Exception` type to handle all other exceptions as the
  last catch.

```java
try {
    //some code
} catch (ExceptionType1 e1) {
    //Catch block
} catch (ExceptionType2 e2) {
    //Catch block
} catch (ExceptionType3 e3) {
    //Catch block
}
```

### Types of Exceptions

There are two exception types, checked and unchecked (also called
runtime).
- The main difference is that checked exceptions are checked when
  compiled, while unchecked exceptions are checked at runtime.
- Thread.sleep() throws an InterruptedException. this is an example
  checked exception. Your code will not compile until you've handled the
  exception.
- Unchecked exceptions: dividing by 0.

Throwable
- https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html
- Errors (irrecoverable)
    + https://docs.oracle.com/javase/8/docs/api/java/lang/Error.html
    + IOError, VirtualMachineError, etc.
- Exception (recoverable)
    + https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Exception.html
    + RuntimeException (unchecked - do not need to handle)
        * https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html
        * NullPointerException, NoSuchElementException,
          UncheckedIOException, etc.
    + Others... (checked - have to handle before compiling)
        * IOException, etc.

### Best Practices

- https://stackify.com/best-practices-exceptions-java/
- https://jenkov.com/tutorials/java-exception-handling/basic-try-catch-finally.html
- https://www.ibm.com/support/pages/best-practice-catching-and-re-throwing-java-exceptions
- Catch `RuntimeException` or more specific Exceptions
- You can catch internal exception and then rethrow a new external
  exception for users / clients, but DO NOT just catch the exception,
  DO NOT log it and then rethrow the same exception.
    + Log and then rethrow the same exception will log the exception's
      messages twice.
        * Code duplication, and litters the log files with duplicates
          entries which makes it much more difficult to troubleshoot
          code.
    + Remember to set the Internal exception as the cause for the
      External exception
    + `throw new ExternalException("Message", InternalException);`
    + `ExternalException` is a class that you need to write, and it
      extends built-in Java exceptions (e.g., RetryableException, etc.)
    + The `Message` should contain some additional information that the
      upper layers do not have access to these data.
- Catch and handle the exceptions at higher layers where you know how to
  deal with the exceptions
    + Throw early (fail-fast) and catch late
    + At lower layers, use `throws` to throw exceptions to higher
      levels, DO NOT `try-catch` and then `throw`.
- Remember to close resources with `finally` or `try-with-resources`.
- Use returned values such as boolean values for optional operations
  that do not need to throw exceptions.
    + EXCEPTION IS EXPENSIVE!!!
    + These operations are optional and the program can continue even
      with failed operations.
- Document the exceptions thrown with javadoc `@throws`

### The try-with-resources statement

- How it is implemented?
    + https://stackoverflow.com/questions/7860137/what-is-the-java-7-try-with-resources-bytecode-equivalent-using-try-catch-finall
- https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html
- A resource is an object that must be closed after the program is
  finished with it.
- The try-with-resources statement ensures that each resource is closed
  at the end of the statement.
- Any object that implements `java.lang.AutoCloseable` can be used as a
  resource.
- If both try-with-resource statement and try block throw exceptions,
  then the exception from the try-with-resource statement is suppressed
    + This is opposite with the try and finally blocks together, the
      exception from the try block is suppressed instead. And the
      exception in the finally block is thrown.
- Only IO resources are required to be closed.

### Throwable `addSuppressed()` method

- https://stackoverflow.com/questions/8946661/jdk-1-7-throwable-addsuppressed-method

## Threads

Java is a multi-threaded programming language.
- The following diagram shows the life-cycle of a thread.

```text
New Thread() -> New --Start()--> Runnable --run()--> Running
                 |                                       |
                 |----> Dead <--End of execution---------|
                          ^                              |
                          |- Waiting <--Sleep(), wait()--|
```

There are two ways to create a thread.

### 1. Extend the Thread class

Inherit from the Thread class, override its `run()` method, and write
the functionality of the thread in the run() method.
- Then you create a new object of your class and call its `start()`
  method to run the thread.

```java
class Loader extends Thread {
    public void run() {
        System.out.println("Hello");
    }
}

class MyClass {
    public static void main (String[] args) {
        Loader obj = new Loader();
        obj.start();
    }
}
```

- Every Java thread is prioritized to help the operating system
  determine the order in which to schedule threads. The priorities range
  from 1 to 10, with each thread defaulting to priority 5. You can set
  the thread priority with the `setPriority()` method.

### 2. Implementing the Runnable interface

Implements the run() method. Then, create a new thread object, pass the
Runnable class to its constructor, and start the Thread by calling the
start() method.
- Thread.sleep() method pauses a Thread for a specified period of time.
  For example, calling Thread.sleep(1000); pause the thread for one
  second.
    + Thread.sleep() throws an InterruptedException, so be sure to
      surround it with a try/catch block.

```java
class Loader implements Runnable {
    public void run() {
        System.out.println("HEllo");
    }
}

class MyClass {
    public static void main(String[] args) {
        Thread t = new Thread(new Loader());
        t.start();
    }
}
```

- It may seem that implementing the Runnable interface is a bit more
  complex than extending from the Thread class. However, implementing
  the Runnable interface is the preferred way to start a Thread because
  it enables you to extend from another class, as well.
    + Java does not allow extending multiple classes (multiple
      inheritance)

## Annotations

- https://docs.oracle.com/javase/tutorial/java/annotations/basics.html

### Introduction

Annotations are a form of metadata and provide information for the
compiler. Annotations have no direct effect on the operation of the code
they annotate.

Annotations have a number of uses:

- Information for the compiler: it can be used by the compiler to detect
  errors or suppress warnings
- Compile-time and deployment-time processing: software tools can
  process annotation information to generate code, XML files, and so
  forth.
- Runtime processing: some annotations are available to be examined at
  runtime

### Annotation Basics

- Format: `@Annotation`
- Can include *elements*: `@Author(name = "Ben", date = "3/2/2002")`
- Annotations can be applied to declarations
    + classes
    + fields
    + methods
    + other program elements
- Replacing comments (easy to maintain comments)

### Declaring an Annotation Type

Suppose that a software group traditionally starts the body of every
class with comments providing important information:

```java
public class Generation3List extends Generation2List {

   // Author: John Doe
   // Date: 3/17/2002
   // Current revision: 6
   // Last modified: 4/12/2004
   // By: Jane Doe
   // Reviewers: Alice, Bill, Cindy

   // class code goes here

}
```

To add this same metadata with an annotation, you must first define the
*annotation type*.

```java
@interface ClassPreamble {
   String author();
   String date();
   int currentRevision() default 1;
   String lastModified() default "N/A";
   String lastModifiedBy() default "N/A";
   // Note use of array
   String[] reviewers();
}
```

After the annotation type is defined, you can use annotations of that
type, with the values filled in, like this:

```java
@ClassPreamble (
   author = "John Doe",
   date = "3/17/2002",
   currentRevision = 6,
   lastModified = "4/12/2004",
   lastModifiedBy = "Jane Doe",
   // Note array notation
   reviewers = {"Alice", "Bob", "Cindy"}
)
public class Generation3List extends Generation2List {

// class code goes here

}
```

To make the information in `@ClassPreamble` appear in javadoc-generated
documentation, you must annotate the `@ClassPreamble` definition with
the `@Documented` annotation:

```java
// import this to use @Documented
import java.lang.annotation.*;

@Documented
@interface ClassPreamble {

   // Annotation element definitions

}
```

### Predefined Annotation Types

Java SE API

#### Annotation Types Used by the Java Compiler

`java.lang`: `@Deprecated, @Override, @SuppressWarnings`

- `@Deprecated`: it marks the element is deprecated and should no longer
  be used.
    + The compiler generates a warning whenever a program uses a method,
      class, or field with the `@Deprecated` annotation.
    + The deprecated elements should also be documented using the
      Javadoc `@deprecated` tag
    + https://www.baeldung.com/java-deprecated

```java
   // Javadoc comment follows
    /**
     * @deprecated
     * explanation of why it was deprecated and what to use instead
     */
    @Deprecated
    static void deprecatedMethod() { }
}
```

- `@Override`: it informs the compiler that the element is meant to
  override an element declared in a superclass.
    + A compiler error if there is no method signature in the
      superclass.
- `@SuppressWarnings`: it tells the compiler to suppress specific
  warnings that it would otherwise generate.
    + two categories: `deprecation` and `unchecked`
    + `unchecked` can occur when interfacing with legacy code written
      before the advent of generics
    + multiple categories: `@SuppressWarnings({"unchecked", "deprecation"})`

```java
   // use a deprecated method and tell
   // compiler not to generate a warning
   @SuppressWarnings("deprecation")
    void useDeprecatedMethod() {
        // deprecation warning
        // - suppressed
        objectOne.deprecatedMethod();
    }
```

#### Annotations That Apply to Other Annotations

`meta-annotations` defined in `java.lang.annotation`

- `@Retention`: it specifies how the marked annotation is stored
    + `RetentionPolicy.SOURCE` - is retained only in the source level
      and is ignored by the compiler
    + `RetentionPolicy.CLASS` - is retained by the compiler at compile
      time, but is ignored by the JVM
    + `RetentionPolicy.RUNTIME` - is retained by the JVM so it can be
      used by the runtime environment
- `@Documented`: it indicates that whenever the specified annotation is
  used those elements should be documented using the Javadoc tool
- `@Target`: it restricts what kind of Java elements the annotation can
  be applied to.
    + `ElementType.ANNOTATION_TYPES` can be applied to an annotation
      type
    + `ElementType.CONSTRUCTOR`
    + `ElementType.FIELD`
    + `ElementType.LOCAL_VARIABLE`
    + `ElementType.METHOD`
    + `ElementType.PACKAGE`
    + `ElementType.PARAMETER`
    + `ElementType.TYPE`
- `@Inherited`: it indicates that the annotation type can be inherited
  from the super class.
    + When the user queries the annotation type and the class has no
      annotation for this type, the class' superclass is queried for the
      annotation type.
    + applies only to class declarations
- `@Repeatable` it is introduced in Java SE 8, indicates that the marked
  annotation can be applied more than once to the same declaration or
  type use

### Type Annotations and Pluggable Type Systems

Before the Java SE 8 release, annotations could only be applied to
declarations. As of the Java SE 8 release, annotations can also be
applied to any `type use`.

- This means that annotations can be used anywhere you use a type
- class instance creation expressions (new)
- casts
- `implements` clauses
- `throws` clauses
- ensuring stronger type checking

The Java SE 8 does not provide a type checking framework, but it allows
you to write (or download) a type checking framework that is implemented
as one or more pluggable modules that are used in conjunction with the
Java compiler.

For example, you want to ensure that a particular variable in your
program is never assigned to null; you want to avoid triggering a
`NullPointerException`. You can write a custom plug-in to check for
this. You would then modify your code to annotate that particular
variable, indicating that it is never assigned to null. The variable
declaration might look like this:

```java
@NonNull String str;
```

When you compile the code, including the NonNull module at the command
line, the compiler prints a warning if it detects a potential problem,
allowing you to modify the code to avoid the error. After you correct
the code to remove all warnings, this particular error will not occur
when the program runs.

You can use multiple type-checking modules where each module checks for
a different kind of error. In this way, you can build on top of the Java
type system, adding specific checks when and where you want them.

With the judicious use of type annotations and the presence of pluggable
type checkers, you can write code that is stronger and less prone to
error.

In many cases, you do not have to write your own type checking modules.
There are third parties who have done the work for you. For example, you
might want to take advantage of the Checker Framework created by the
University of Washington. This framework includes a NonNull module, as
well as a regular expression module, and a mutex lock module.

### Repeating Annotations

#### Creating and Using Annotation Type

For example, you are writing code to use a timer service that enables
you to run a method at a given time or on a certain schedule, similar to
the UNIX `cron` service. Now you want to set a timer to run a method,
`doPeriodicCleanup`, on the last day of the month and on every Friday at
11:00 p.m. To set the timer to run, create an `@Schedule` annotation and
apply it twice to the `doPeriodicCleanup` method. The first use
specifies the last day of the month and the second specifies Friday at
11p.m., as shown in the following code example:

```java
@Schedule(dayOfMonth="last")
@Schedule(dayOfWeek="Fri", hour="23")
public void doPeriodicCleanup() { ... }
```

The previous example applies an annotation to a method. You can repeat
an annotation anywhere that you would use a standard annotation. For
example, you have a class for handling unauthorized access exceptions.
You annotate the class with one @Alert annotation for managers and
another for admins:

```java
@Alert(role="Manager")
@Alert(role="Administrator")
public class UnauthorizedAccessException extends SecurityException { ... }
```

For compatibility reasons, repeating annotations are stored in a
container annotation that is automatically generated by the Java
compiler. In order for the compiler to do this, two declarations are
required in your code.

**Step 1: Declare a Repeatable Annotation Type**

The annotation type must be marked with the `@Repeatable` meta-
annotation. The following example defines a custom `@Schedule`
repeatable annotation type:

```java
import java.lang.annotation.Repeatable;

@Repeatable(Schedules.class)
public @interface Schedule {
  String dayOfMonth() default "first";
  String dayOfWeek() default "Mon";
  int hour() default 12;
}
```

The value of the `@Repeatable` meta-annotation, in parentheses, is the
type of the container annotation that the Java compiler generates to
store repeating annotations. In this example, the containing annotation
type is Schedules, so repeating `@Schedule` annotations is stored in an
`@Schedules` annotation.

Applying the same annotation to a declaration without first declaring it
to be repeatable results in a compile-time error.

**Step 2: Declare the Containing Annotation Type**

The containing annotation type must have a value element with an array
type. The component type of the array type must be the repeatable
annotation type. The declaration for the Schedules containing annotation
type is the following:

```java
public @interface Schedules {
    Schedule[] value();
}
```

### Retrieving Annotations

There are several methods available in the Reflection API that can be
used to retrieve annotations. The behavior of the methods that return a
single annotation, such as `AnnotatedElement.getAnnotation(Class<T>)`,
are unchanged in that they only return a single annotation if one
annotation of the requested type is present. If more than one annotation
of the requested type is present, you can obtain them by first getting
their container annotation. In this way, legacy code continues to work.
Other methods were introduced in Java SE 8 that scan through the
container annotation to return multiple annotations at once, such as
`AnnotatedElement.getAnnotationsByType(Class<T>)`. See the
`AnnotatedElement` class specification for information on all of the
available methods.

### Design Considerations

When designing an annotation type, you must consider the *cardinality*
of annotations of that type. It is now possible to use an annotation
zero times, once, or, if the annotation's type is marked as
`@Repeatable`, more than once. It is also possible to restrict where an
annotation type can be used by using the `@Target` meta-annotation. For
example, you can create a repeatable annotation type that can only be
used on methods and fields. It is important to design your annotation
type carefully to ensure that the programmer using the annotation finds
it to be as flexible and powerful as possible.

## Generics

- https://docs.oracle.com/javase/tutorial/java/generics/index.html
- https://docs.oracle.com/javase/tutorial/extra/generics/index.html
- Producer vs. Consumer
    + https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super

### Wildcards

- `?`: unbound
- `? extends Foo`: upper bounded
- `? super Foo`: lower bounded

## The Platform Environment

An application runs in a platform environment, defined by the underlying
operating system, the Java virtual machine, the class libraries, and
various configuration data supplied when the application is launched.

### Configuration Utilities

### System Utilities

#### System Properties

- https://stackoverflow.com/questions/7054972/java-system-properties-and-environment-variables
- The Java platform itself uses a Properties object to maintain its own
  configuration.
- The `System` class maintains a `Properties` object that describes the
  configuration of the current working environment.
- System properties include information about the current user, the
  current version of the Java runtime, and the character used to
  separate components of a file path name.

### PATH and CLASSPATH environment variables

- Set the PATH environment variable if you want to be able to
  conveniently run the executables (javac.exe, java.exe, javadoc.exe,
  and so on) from any directory without having to type the full path of
  the command.
    + If you do not set the PATH variable, you need to specify the full
      path to the executable every time you run it.
- The class path tells the JDK tools and applications where to find
  third-party and user-defined classes that are not extensions or part
  of the Java platform.
    + Classes that are part of the JRE, JDK platform, and extensions
      should be defined through other means, such as the bootstrap class
      path or the extensions directory.
    + Setting class path: CLASSPATH environment variable, or
      `-classpath/-cp` option in `java` CLI.
    + https://howtodoinjava.com/java/basics/java-classpath/

### JAVA_TOOL_OPTIONS environment variable

- In many environments the command line is not readily accessible to
  start the application with necessary command-line options.
    + This often arises with applications that use embedded VMs (meaning
      they use the Java Native Interface (JNI) Invocation API to start
      the VM), or where the startup is deeply nested in scripts.
    + In these environments the JAVA_TOOL_OPTIONS environment variable
      can be useful to augment a command line.
- More details in `jvm.md`

# Data Structures

## Primitive types

In Java, every value is either a reference to an object, or it belongs
to one of the eight primitive types.

### Number types

| Type    | Description                                                                | Size    | Example      |
| -       | -                                                                          | -       | -            |
| int     | The integer type, range Integer.MIN_VALUE to Integer.MAX_VALUE             | 4 bytes | 1, 2, 3      |
| byte    | The type describing a single byte, range -128 ... 127                      | 1 byte  |              |
| short   | The short integer type, range -32,768 ... 32,767                           | 2 bytes |              |
| long    | The long integer type                                                      | 8 bytes |              |
| double  | The double-precision floating-point type                                   | 8 bytes | 0.1          |
| float   | The single-precision floating-point type                                   | 4 bytes | 1E6, 2.96E-2 |
| char    | The character type, representing code units in the Unicode encoding scheme | 2 bytes |              |
| boolean | THe type with the two truth values false and true                          | 1 bit   |              |

When a value such as 6 or 0.335 occurs in a Java program, it is called a
**number literal**.

A numeric computation overflows if the result falls outside the range
for the number type.
- Using `BigInteger` type to prevent overflow errors.

**Rounding errors** occur when an exact representation of a floating-
point number is not possible.
- Using `BigDecimal` type to prevent rounding errors.

Constants:
- In a method: `final double NICKEL_VALUE = 0.05;`
- In a class: `public static final double LITERS_PER_GALLON = 3.785;`

Big Numbers:

```java
BigInteger n = new BigInteger("1000000");
BigInteger r = n.multiply(n);
System.out.println(r);

BigDecimal d = new BigDecimal("4.35");
BigDecimal e = new BigDecimal("100");
BigDecimal f = d.multiply(e);
System.out.println(f);
```

Any number that is not completely self-explanatory should be declared as
a named constant. Or write comments to explain its functions and why you
choose them.

Mathematical methods

| Method            | Returns                      | Method            | Returns                      |
|-------------------|------------------------------|-------------------|------------------------------|
| Math.sqrt(x)      | Square root of x             | Math .abs(x)      | Absolute value               |
| Math.pow(x, y)    | x to the y                   | Math.max(x, y)    | The larger                   |
| Math.sin(x)       | Sine of x (radian)           | Math.min(x, y)    | The smaller                  |
| Math.cos(x)       | Cosine                       | Math.exp(x)       | e to the x                   |
| Math.tan(x)       | Tangent                      | Math.log(x)       | Natural log                  |
| Math.round(x)     | Closest integer              | Math.log10(x)     | Decimal log                  |
| Math.ceil(x)      | Smallest integer &geq; x     | Math.floor(x)     | Largest integer &leq; x      |
| Math.toRadians(x) | Convert x degrees to radians | Math.toDegrees(x) | Convert x radians to degrees |

## Enum

- An enum value is a named constant in a set of values that is defined
  by an enumeration type, or enum type.
    + Enum value (named constant) can contain data fields and methods.
- https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.9
- https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html
- An `enum` declaration specifies a new `enum class`, a restricted kind
  of class that defines `a small set of named class instances`.
- `EnumDeclaration`:
    + `{ClassModifier} enum TypeIdentifier [ClassImplements] EnumBody`
    + `public enum Mode implements Switchable {...}`
- `EnumBody`
    + List of zero or more Enum constants.
    + Enum body declarations.
- Implicitly `final` or `sealed`
    + Therefore, it cannot be subclassed or extended (its methods
      cannot be overriden)
- Extends `java.lang.Enum` class
    + Therefore, it cannot extend other classes due to Java is a single
      inheritance language.
- The enum body declarations can contain `abstract` methods
    + All enum constants must have class bodies that provide concrete
      implementations of the abstract methods.
- It can implement one or more interfaces.
    + Implicitly implement `Comparable` and `Serializable` interfaces
        * `Serializable`: can use to achieve Singleton pattern

### Practical Usage

- Use cases
    + https://www.baeldung.com/a-guide-to-java-enums
    + https://webtechie.be/post/2023-03-22-hidden-beauties-of-java-enums/
- Simplify Enum code with Lambdas
    + https://www.reddit.com/r/java/comments/12soujh/comment/jgzw8ww/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button
    + https://stackoverflow.com/questions/23361418/lambdas-in-the-classical-operation-enum-example


## String

### Types

- String: immutable character sequences
- StringBuffer: mutable character sequences, thread-safe
- StringBuilder: mutable character sequences, single thread

### Declaration and initialization

```java
String str1 = "Hello World!";
String str2 = new String("Hello World");
```

### String operations

| Statement                                                | Result               | Comment                                                                                                                                |
| -                                                        | -                    | -                                                                                                                                      |
| String str = "Ja"; str = str + "va";                     | str is set to "Java" | When applied to strings, + denotes concatenation                                                                                       |
| String greeting = "H & S"; int n = greeting.length();    | n is set to 5        | Each space counts as one character                                                                                                     |
| str.charAt(1)                                            |                      |                                                                                                                                        |
| String str = "Sally"; String str2 = str.substring(1, 4); | str2 is set to "all" | Extracts the substring starting at position 1 and ending before position 4 (starting with first good data and end with first bad data) |

## Array

```java
// Have to "new" an array when we initialize it
double[] values = new double[10];

// An array of objects
BankAccount[] accounts = new BankAccount[10];
// We have to initialize the array manually
for (int i = 0; i < 10; i++)
{
    accounts[i] = new BankAccount();
}
```

```java
import java.util.Arrays

string str = Arrays.toString(values);
double[] prices = Arrays.copyOf(values, values.length);
Arrays.sort(values);
Arrays.sort(values, 0, currentSize);
```

### Methods with a variable number of arguments

```java
public void addScores(int... values)
{
    for (int i = 0; i < values.length; i++) // values is an int[]
    {
        totalScore = totalScore + values[i];
    }
}

fred.addScores(10, 7);
fred.addScores(1, 7, 2, 9);
```

### Two-Dimensional Arrays with variable row lengths

```java
int[][] a = new int[3][];
for (int i = 0; i < a.lenght; i++)
{
    a[i] = new int[i+1];
}
```

## Collections Framework

- https://en.wikipedia.org/wiki/Java_collections_framework
- https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/doc-files/coll-overview.html
- https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/doc-files/coll-reference.html
- https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html

- Iterable (interface)
    + Collection (interface)
        + List (interface)
        + Queue (interface)
        + Set (interface)

### Array List

- Array lists can grow and shrink as needed.
- The ArrayList class supplies methods for common tasks, such as
  inserting and removing elements.

ArrayList are created with an initial size, but when this size is
exceeded, the collection is automatically enlarged.
- When objects are removed, the ArrayList may shrink in size. Note that
  the ArrayList class is in the java.util package, so it's necessary to
  import it before using it.

```java
import java.util.ArrayList;

ArrayList colors = new ArrayList();
// You can optionally specify a capacity and type of objects
ArrayList<String> colors = new ArrayList<String>(10);
```

>ArrayLists store objects. Thus, the type specified must be a class
type. You cannot pass, for example, `int` as the objects' type. Instead,
use the special class types that correspond to the desired value type,
such as `Integer` for int, `Double` for double, and so on.

```java
import java.util.ArrayList;

public class MyClass {
    public static void main(String[] args) {
        ArrayList<String> colors = new ArrayList<String>();
        colors.add("Red");
        colors.add("Blue");
        colors.add("Green");
        colors.add("Orange");
        colors.Remove("Green");

        System.out.println(colors);
    }
}
// Output: [Red, Blue, Orange]
```

```java
import java.util.ArrayList

ArrayList<String> friends = new ArrayList<String>();
friends.add("Cindy");
String name = friends.get(i);
friends.set(i, "Harry");

// yields two references to the same array list
ArrayList<String> friends = names;

// copy array lists
ArrayList<String> newNames = new ArrayList<String>(names);

// Wrappers and auto-boxing
ArrayList<double>   // WRONG
ArrayList<Double> values = new ArrayList<Double>();
```

Useful methods:

| Name           | Description                                               |
|----------------|-----------------------------------------------------------|
| add(obj)       | Add a new object to the ArrayList                         |
| remove(obj)    | Remove an object from the ArrayList                       |
| contains()     | Returns true if the list contains the specified element   |
| get(int index) | Returns the element at the specified position in the list |
| size()         | Returns the number of elements in the list                |
| clear()        | Removes all the elements from the list                    |

### LinkedList

```java
import java.util.LinkedList;

public class MyClass {
    public static void main(String[] args) {
        LinkedList<String> c = new LinkedList<String>();
        c.add("Red");
        c.add("Blue");
        c.add("Green");
        c.add("Orange");
        c.remove("Green");

        System.out.println(c);
    }
}
//Outputs: [Red, Blue, Orange]
```

Summary:
- Use an ArrayList when you need rapid access to your data.
- Use a LinkedList when you need to make a large number of inserts
  and/or deletes.

### HashMap

Arrays and Lists store elements as ordered collections, with each
elements given an integer index.
- HashMap is used for storing data collections as key and value pairs.
- One object is used as a key (index) to another object (the value).
- The `put`, `remove`, and `get` methods are used to add, delete, and
  access values in the HashMap.

```java
import java.util.HashMap;

public class MyClass {
    public static void main(String[] args) {
        HashMap<String, Integer> points = new HashMap<String, Integer>();
        points.put("Amy", 154);
        points.put("Dave", 42);
        points.put("Rob", 733);
        System.out.println(points.get("Dave"));
    }
}
//Outputs 42
```

A HashMap cannot contain duplicate keys. Adding a new item with a key
that already exists overwrites the old element.
- The `containsKey` and `containsValue` methods that determine the
  presence of a specified key or value.
- It you try to get a value that is not present in you map, it returns
  the value of null.

#### Map.Entry (Tuple / Pair)

- https://www.baeldung.com/java-map-entry
- https://stackoverflow.com/questions/521171/a-java-collection-of-value-pairs-tuples

### Sets

A Set is a collection that cannot contain duplicate elements. It models
the mathematical set abstraction.
- One of the implementations of the Set is the HashSet class.

```java
import java.util.HashSet;

public class MyClass {
    public static void main(String[] args) {
        HashSet<String> set = new HashSet<String>();
        set.add("A");
        set.add("B");
        set.add("C");
        System.out.println(set);
    }
}
//Outputs: [A, B, C]
```

The HashSet class does not automatically retain the order of the
elements as they are added. To order the elements, use a LinkedHashSet,
which maintains a linked list of the set's elements in the order in
which they were inserted.

### Collections class

```java
import java.util.Collections;

public class MyClass {
    public static void main(String[] args) {
        ArrayList<Integer> nums = new ArrayList<Integer>();
        nums.add(3);
        nums.add(36);
        nums.add(73);

        Collections.sort(nums);
        System.out.println(nums);
    }
}
```

- sort, max, min, reverse, shuffle

## Record classes and Sealed Types

- Algebraic Data Types
    + In computer programming, especially functional programming and
      type theory, an algebraic data type (ADT) is a kind of composite
      type, i.e., a type formed by combining other types.
    + https://en.wikipedia.org/wiki/Algebraic_data_type
- Pattern matching
    + https://openjdk.org/projects/amber/design-notes/patterns/pattern-matching-for-java
- https://openjdk.org/projects/amber/design-notes/records-and-sealed-classes
- Record classes
    + https://openjdk.org/jeps/359
- Sealed Classes
    + https://openjdk.org/jeps/360
- https://nipafx.dev/java-record-semantics/
- https://stackoverflow.com/questions/61306802/lombok-getter-setter-vs-java-14-record

# Iterators

An Iterator is an object that enables to cycle through a collection,
obtain or remove elements.

```java
import java.util.Iterator;
import java.util.LinkedList;

public class MyClass {
    public static void main(String[] args) {
        LinkedList<String> animals = new LinkedList<String>();
        animals.add("fox");
        animals.add("cat");
        animals.add("dog");
        animals.add("rabbit");

        Iterator<String> it = animals.iterator();
        while (it.hasNext()) {
            String value = it.next();
            System.out.println(value);
        }
    }
}
//Outputs: fox
```


# Object-Oriented Programming (OOP) - Classes and Objects

## More on Classes

### Initializing Fields

- https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html
- https://www.baeldung.com/java-static-variables-initialization
- Initialize class variables
    + Static initialization blocks
    + `private static varType initializeClassVariable()`
- Initialize instance variables
    + Initialization blocks: no `static` keyword
    + `protected final varType initializeInstanceVariable()`
        * Has to be `final`
        * `protected` allow subclasses to reuse the method

## Instance Variables and Encapsulation

An instance is an object of the class.
- Each object of a class has its own set of instance variables.

A black box is any device whose inner workings are hidden.
- Its interface with the outside world is well-defined.
- The process of hiding implementation details while publishing an
  interface is called encapsulation.

Benefits of encapsulation:
- Simplify the process of making complicated things from other simple
  components.
- encapsulation also helps with diagnosing errors.

## Public Interface

What methods should you provide?
- What information should you give the programmers who use this class?

Mutators: modify the values and don't return a value.
- Accessors: return a value

```java
public double getBalance()
{
    // TODO: fill in implementation
    return 0;
}
```

## Class Implementation

### Instance Variables

### Constructor

A constructor has a simple job: to initialize the instance variables of
an object.

>When you implement constructors, be sure that each constructor
initializes all instance variables, and that you make use of all
parameter variables.

### Methods

When you implement a method, ask yourself whether it is an accessor or
mutator method.

## The `this` reference

When you call a method, you pass two kinds of inputs to the method:
- The object on which you invoke the method
- The method arguments

When you implement the method, you provide a parameter variable for each
argument. But you don't need to provide a parameter variable for the
object on which the method is being invoked.
- That object is called the **implicit parameter**.
- All other parameter variables are called **explicit parameters**.

The `this` reference denotes the implicit parameter.
- The `this` reference can also be used to distinguish between instance
  variables and local or parameter variables.

A method call without an implicit parameter is applied to the same
object.

```java
public class BankAccount
{
    ...
    public void monthlyFee()
    {
        withdraw(10);
        // this.withdraw(10);
    }
}
```

## Calling one constructor from another

```java
public class BankAccount
{
    public BankAccount(double initialBalance)
    {
        balance = initialBalance;
    }

    public BankAccount()
    {
        this(0);
    }
}
```

## Access Modifiers - Encapsulation - Access Control

| Modifiers             | Description                                                                                                                                              |
|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| public                | Accessible from any other class                                                                                                                          |
| default (no modifier) | A variable or method declared with no access control modifier is available to any other class in the same package.                                       |
| protected             | Provides the same access as the default access modifier, with the addition that subclasses can access protected methods and variables of the superclass. |
| private               | Accessible only within the declared class itself                                                                                                         |

- The `package-private` (default or no modifier) is useful where you
  want to share things between your classes, but you also want to vend
  out these classes to the public (for example client code)
    + With `package-private`, people cannot extends your classes and
      access your stuff similar as `protected`

## Inheritance

- https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html

Use the `extends` keyword.

```java
class Dog extends Animal {
    // some code
}
```

Here, Dog is the subclass, and animal is the superclass.

You can access the superclass from the subclass using the `super`
keyword. For example, `super.var` accesses the var member of the
superclass.

## Anonymous classes

Anonymous classes are a way to extend the existing classes on the fly.
- The modification is applicable only to the current object, and not the
  class itself. So if we create another object of that class, the object
  will use the method is defined in the class.

For example, consider having a class Machine:

```java
class Machine() {
    public void start() {
        System.out.println("Starting...");
    }
}

public static void main(String[] args) {
    Machine m = new Machine() {
        @Override public void start() {
            System.out.println("Wooooo");
        }
    };

    m.start();
}
```

The `@Override` annotation is used to make your code easier to
understand, because it makes it more obvious when methods are
overridden.

## Polymorphism

One method with multiple implementations.

Here is an example in Java: Dog and Cat are classes that inherit from
the Animal class. Each class has its own implementation of the makeSound
() method.

```java
class Animal {
    public void makeSound() {
        System.out.println("Grr...");
    }
}

class Cat extends Animal {
    public void makeSound() {
        System.out.println("Meow");
    }
}

class Dog extends Animal {
    public void makeSound() {
        System.out.println("Woof");
    }
}
```

As all Cat and Dog objects are Animal objects, we can do the following
in main:

```java
public static void main(String[] args) {
    Animal a = new Dog();
    Animal b = new Cat();
    a.makeSound();  //Outputs "Woof"
    b.makeSound();  //Outputs "Meow"
}
```

This demonstrate that you can use the Animal variable  without actually
knowing that it contains an object of the subclass. This is very useful
when you have multiple subclasses of the superclass.

#### Method overriding

A subclass can define a behavior that's specific to the subclass type,
meaning that a subclass can implement a parent class method based on its
requirements. This feature is known as method overriding.

Rules for Method Overriding:
- Should have the same return type and arguments
- The access level cannot be more restrictive than the overriden
  method's access level.
    + Example: if the superclass method is declared public, the
      overriding mthod in the subclass can be neither private nor
      protected.
- A method declared final or static cannot be overridden
- If a method cannot be inherited, it cannot be overridden
- Constructors cannot be overridden

#### Method overloading

When methods have the same name, but different parameters, it is known
as method overloading.

## Abstraction

In Java, abstraction is achieved using abstract classes and interfaces.

### Abstract classes

- When to use them?
    + When you want to share states or functionalities.

An abstract class is defined using the `abstract` keyword.
- If a class is declared abstract it cannot be instantiated (you cannot
  create objects of that type).
- To use a abstract class, you have to inherit it from another class.
    + You cannot instantiate an object from an abstract class
- Any class that contains an abstract method should be defined as
  abstract.
    + An abstract method is a method that is declared without an
      implementation (without braces, and followed by a semicolon):
      `abstract void walk();`

```java
abstract class Animal {
    int legs = 0;
    abstract void makeSound();
}

class Cat extends Animal {
    public void makeSound() {
        System.out.println("Meow");
    }
}
```

Different animals make different sounds, that's why we define an
abstract class Animal, and leave the implementation of how they make
sounds to the subclasses.
- This is used when there is no meaningful for the method in the
  superclass.

### Interfaces


- When to use?
    + When you want to avoid Inheritance and coupling. (this aligns
      more with composition than abstract classes)
    + If you plan to vend out an interface for external teams to
      use. Interfaces allow you to change implementations without
      breaking customers' systems and it allows your customers freedom
      to implment the interfaces.

An interface is a completely abstract class that contains only abstract
methods.

Specifications for interfaces:
- Defined using the `interface` keyword.
- May contain only `static` final variables.
- Cannot contain a constructor because interfaces cannot be instantiated
- Interfaces can extend other interfaces
- A class can implement any number of interfaces

```java
interface Animal {
    public void eat();
    public void makeSound();
}

class Cat implements Animal {
    public void makeSound() {
        System.out.println("Meow");
    }

    public void eat() {
        System.out.println("omnomnom");
    }
}
```

Properties of interfaces
- An interface is implicitly abstract. You do not need to use the
  abstract keyword while declaring an interface.
- Each method in an interface is also implicitly abstract, so the
  abstract keyword is not needed.
- Methods in an interface are implicitly public.

>A class can inherit from just one superclass, but can implement multiple
interfaces!

>When you implement an interface, you need to override all of its
methods.

#### Static and Default methods in Interfaces

- https://www.baeldung.com/java-static-default-methods
- Default methods are to provide additional functionality without
  breaking the existing implementations.
    + Provide backward compatibility to the existing interface.
- Default methods in interfaces vs abstract classes
    + https://www.baeldung.com/java-interface-default-method-vs-abstract-class
    + Abstract classes: instantiation and constructors, private members,
      override `Object`'s methods, shared members across subclasses.



## Nesting classes

- Nesting classes
    + Static nesting classes
    + Non-static nesting classes (inner classes)

## The equals() method

Each object has a predefined `equals()` method that is used for
semantic equality testing.
- But, to make it work for our classes, we need to override it and check
  the conditions we need.
- It can be auto-generated by the IDE.

```java
class Animal {
  String name;
  Animal(String n) {
    name = n;
  }
  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    return result;
  }
  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    Animal other = (Animal) obj;
    if (name == null) {
      if (other.name != null)
        return false;
    } else if (!name.equals(other.name))
      return false;
    return true;
  }
}
```


The automatically generated hashCode() method is used to determine where
to store the object internally.
- Whenever you implement equals, you MUST also implement hashCode.

## Plain Old Java Object (POJO)

POJO refers to a Java object (instance of definition) that isn't bogged
down by framework extensions (also no conventions)

Pros
- Simplify code
- To better testing, flexibility, and ability to make new decisions in
  the future
Cons
- Higher learning curves how to use it since no conventions

- POJOs vs JavaBean
    + https://www.baeldung.com/java-pojo-class
    + JavaBean adds some conventions
        * Access levels – our properties are private and we expose getters and setters
        * Method names – our getters and setters follow the getX and setX convention (in the case of a boolean, isX can be used for a getter)
        * Default Constructor – a no-argument constructor must be present so an instance can be created without providing arguments, for example during deserialization
        * Serializable – implementing the Serializable interface allows us to store the state

## Object class

- String toString()
- int hashCode()
- boolean equals(Object o)
- Class getClass()
- void finalize()
    + performs any actions that we want before Garbage Collector
      disposes this object
- Object clone()
- wait(), notify(), notifyAll() => concurrency

# Technologies

## [Servlet](https://en.wikipedia.org/wiki/Java_servlet)

- Java program running on server, receive requests and can respond them.

## [Java Server Pages - JSP](https://en.wikipedia.org/wiki/JavaServer_Pages)

### Introduction to JSP

- Create dynamically generated web pages based on HTML, XML.
    + Server-side programming technology
    + JSP has access to all Java APIs (JDBC, JNDI, EJB, JAXP, etc)
    + A part of Java EE
- To deploy and run JSP, a compatible web server with a servlet
  container, such as [Apache Tomcat](http://tomcat.apache.org/) or
  [Jetty](http://www.eclipse.org/jetty/).

![Life of a JSP file](http://upload.wikimedia.org/wikipedia/commons/0/03/JSPLife.svg "Life of a JSP file")

## Expression Language (EL)

- Introduction to EL
    + Access to Java Beans/Entities/Object components
    + Arithmetic and  logical expressions
    + Can use integers, floating point numbers, strings, built-in
      constant true/false, and null
- Simple Syntax
    +

## Build Java project

The "Build" is a process that covers all the steps required to create a
"deliverable" of your software. In the Java world, this typically
includes:

1. Generating sources (sometimes).
2. Compiling sources.
3. Compiling test sources.
4. Executing tests (unit tests, integration tests, etc).
5. Packaging (into jar, war, ejb-jar, ear).
6. Running health checks (static analyzers like Checkstyle, Findbugs, PMD, test coverage, etc).
7. Generating reports.

So as you can see, compiling is only a (small) part of the build (and
the best practice is to fully automate all the steps with tools like
**Maven** or Ant and to run the build continuously which is known as
**Continuous Integration**).

# Development Tools

## IDE

- [Eclipse](https://www.eclipse.org/)
- [Netbean](https://netbeans.org/)

## Frameworks

### Spring

MVC is popular and is compatible with the **Servlets Framework**.
[JHipster](https://jhipster.github.io/) combines it with **AngularJS**
and its command line stack of Bower etc. Or it can be used with the
traditional [JSP](https://en.wikipedia.org/wiki/JavaServer_Pages) (which
is becoming less popular and doesn't work well with emedded web
servers), or with Springs's new recommendation
[Thymeleaf](http://www.thymeleaf.org/).

### Hibernate

- Something

## Testing

- Unit test: JUnit, TestNG
- Simulation user's interaction: Selenium
- Code coverage: Cobertura (calculates the percentage of code accessed
  by tests. It can be used to identify which parts of your Java program
  are lacking test coverage.)
- Continuous integration: Jenkins, Hudson
- Mock libraries: Mockito
- Matchers
    + Hamcrest
        * https://hamcrest.org/JavaHamcrest/


## Build Tools

### Ant

### Maven

### Gradle

# Tutorials

## Input and Output

### Input

```java
import java.util.Scanner;
...
Scanner in = newScanner(System.in);
...
System.out.print("Please enter the number of bottles: ");
int bottles = in.nextInt();

System.out.print("Enter price: ");
double price = in.nextDouble();

System.out.print("Enter your name: ");
String name = in.next(); // Get a word without spaces
String name = in.nextLine(); // Get the whole line with spaces
```

### Formatted Output

```java
System.out.printf("%10.2f", price);
System.out.printf("Quantity: %d Total: %10.2f", quantity, total);
```

```
| Format String  | Sample Output  | Comments                                                                              |
|----------------|----------------|---------------------------------------------------------------------------------------|
| "%d"           | 24             | Use d with an integer                                                                 |
| "%5d"          | ___24          | Spaces are added so that the field width is 5                                         |
| "Quantity:%5d" | Quantity:   24 | Characters inside a format string but outside a format specifier appear in the output |
| "%f"           | 1.21997        | Use f with a floating-point number                                                    |
| "%.2f"         | 1.22           | Prints two digits after the decimal point                                             |
| "%7.2f"        | ___1.22        | Spaces are added so that the field width is 7                                         |
| "%s"           | Hello          | Use s with a string                                                                   |
| "%d %.2f"      | 24 1.22        | You can format multiple values at once                                                |
```

### Using Dialog Boxes

```java
// This method returns a String object
String input = JOptionPane.showInputDialog("Enter price:");

// Use the Integer.parseInt and Double.parseDouble to convert the string
// to a number
double price = Double.parseDouble(input);

// Display output in a dialog box
JOptionPane.showMessageDialog(null, "Price: " + price);
```

## Working with Files

The `java.io` package includes a File class that allows you to work with
files.

```java
import java.io.File;

public class MyClass {
    public static void main(String[] args) {
        File x = new File("/tmp/test.txt");
        if (x.exists()) {
            System.out.println(x.getName() + "exists!");
        } else {
            System.out.println("The file does not exist");
        }
    }
}
```

### Reading a File

```java
import java.util.Scanner;

try {
    File x = new File("/tmp/test.txt");
    Scanner sc = new Scanner(x);
    while(sc.hasNext()) {
        System.out.println(sc.next());
    }
    sc.close();
} catch (FileNotFoundException e){
    e.printStackTrace();
}
```

The file's contents are output word by word because the next() method
returns each word separately.

### Creating & Writing Files

```java
import java.util.Formatter;

public class MyClass {
    public static void main(String[] args) {
        try {
            Formatter f = new Formatter("/tmp/test.txt");
            f.format("%s %s %s", "1", "John", "Smith \r\n");
            f.format("%s %s %s", "2", "Amy", "Brown");
            f.close();
        } catch (Exception e) {
            System.out.println("Error");
        }
    }
}
```

This creates an empty  file at the specified path. If the file already
exists, this will overwrite it.

## Reflection

- https://www.baeldung.com/java-reflection
- Java 17: Strongly encapsulate JDK internals
    + https://openjdk.org/jeps/403
    + Reflection is restricted, and only explicitly allowed code can be
      accessed with reflection.
- Some ways to go with reflection for JDK17+
    + https://www.reddit.com/r/java/comments/p9ymhb/what_exactly_is_the_reason_for_denying_reflection/
    + Serialization libraries can have several options:
        * Use records
        * Get permission from the relfected class to us it by obtainning
          a Lookup: https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html
        * Ask the application for permission to access the reflected
          classes by declaring its packages as open or specifying
          `--add-opens` on the command line.
- [Using reflection to set attribute](http://stackoverflow.com/questions/14374878/using-reflection-to-set-an-object-property)


### Proxy

- Proxies are wrappers that pass function invocation through their own
  facilities (usually onto real methods underneath the wrapper,
  potentially, adding some functionality)
    + Invoke a query to database, and then transform or pre-process the
      responses before returning the results.
- https://www.baeldung.com/java-dynamic-proxies
- https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html


## Debug

- [List of debug tools](http://blog.takipi.com/java-debugger-the-definitive-list-of-tools/)

# Java Versions

- https://openjdk.org/projects/jdk/
    + Official list of JEPs
- https://en.wikipedia.org/wiki/Java_version_history
    + List of JEPs and support timeline
- Language changes portion of the new JDK (JDK can contains other
  changes that are not language changes)
    + https://docs.oracle.com/en/java/javase/21/language/java-language-changes.html
- API diff between JDK versions
    + https://javaalmanac.io/


## Java 8 vs. Java 11

- https://learn.microsoft.com/en-us/java/openjdk/reasons-to-move-to-java-11
- https://www.baeldung.com/java-11-new-features

## Java 11 vs. Java 17

- https://mydeveloperplanet.com/2021/09/28/whats-new-between-java-11-and-java-17/
- https://blog.idrsolutions.com/java-17-vs-java-11/
- Upgrade to Java 17: Why and How?
    + https://blogs.oracle.com/javamagazine/post/its-time-to-move-your-applications-to-java-17-heres-why-and-heres-how

# AspectJ

- https://www.baeldung.com/aspectj
- https://en.wikipedia.org/wiki/AspectJ
- https://stackoverflow.com/questions/4313789/what-is-aspectj-good-for

# HTTP Clients

- https://www.wiremock.io/post/java-http-client-comparison
    + HttpURLConnection
    + Java 11+ HttpClient
    + Apache HttpClient
    + OkHttpClient
    + AsyncHttpClient
    + Jetty HttpClient

# Monitoring

- `@Timed` annotations
    + https://www.baeldung.com/timed-metrics-aspectj

# Tips & Tricks

## Different ways to deal with null values

- https://www.baeldung.com/java-avoid-null-check
- null check
    + `Objects.requireNonNull()`
    + Using Guava's Preconditions
    + Lombok's `@NonNull` annotations or other `@NonNull` annotations
- Using `Optional` to design better APIs

## Fields vs Parameters to methods

```
In layman's words:

- methods should have as few arguments as possible ( Martin's Clean Code )
- one of the features of objects is than they can (and should) have a
  state
- non-static methods that don't operate on the object's state,
  i.e. receive everything as parameters, are not cohesive
- non-cohesive methods might as well be made static and grouped in an
  utility class

Again, in my humble opinion non-cohesive methods belong to an utility
class and not to a class with a domain name.
```

## Analyze memory utilization

- Garbage collector logs: analyze heap space
    + https://sematext.com/blog/java-garbage-collection-logs/

## Instance/Class Variables vs local variables

- Having an instance / class variable vs passing parameters with local
  variables.
    + https://stackoverflow.com/questions/346169/when-to-use-an-object-instance-variable-versus-passing-an-argument-to-the-method
    + Life time of the data in the variables.

## Sort a list

- https://www.techiedelight.com/sort-list-of-objects-using-comparator-java/
    + `Comparator.comparing...`

## getType() vs. getClass()

- https://stackoverflow.com/q/26948953/1683888
- `someObject.getClass()`: returns a class object of the `runtime` type
  of `someObject`.
    * This is available on every object.
    * Class object of generics are kinda complicated to get.
- `someField.getType()`: returns a class object of the `declared` type of the
  field that `someField` referes to.
    * This does not have on every objects.
    * It's defined by some classes for some purposes.

## Divide a list to lists of n size

- https://e.printstacktrace.blog/divide-a-list-to-lists-of-n-size-in-Java-8/
- Library:
    + Google Guava: `Lists.partition(List list, int size)`
    + Apache Commons: `ListUtils.partition(List list, int size)`

## Deep copy objects

- Using a JSON library to convert the object to String, then convert the
  String to a new copied object.
    + JSON library: Jackson, Gson, etc.
- https://www.baeldung.com/java-deep-copy

## Loading resources (files)

- https://docs.oracle.com/javase/8/docs/technotes/guides/lang/resources.html
- https://mkyong.com/java/java-read-a-file-from-resources-folder/
- https://stackoverflow.com/questions/3861989/preferred-way-of-loading-resources-in-java
- https://www.baeldung.com/java-classpath-resource-cannot-be-opened
- Using `getClass().getResource()` or `getClass().getResourceAsStream()`
    + This way it uses the same class loader as the class itself, so it
      can access the JAR's resources.
- `ClassLoader.getSystemResource()` will use the system class loader,
  and sometimes it cannot access the JAR's resources.
    + For example, in AWS Lambda deployment package.

## Immutability (Immutable)

- Google Guava library
    + `ImmutableX`
    + Create a copy of object, so safer but more expensive
- Java's built-in `ImmutableX`
    + A wrapper to the object, so if there is another reference to the
      object, you still can change the object.
    + https://docs.oracle.com/en/java/javase/11/core/creating-immutable-lists-sets-and-maps.html


## Default parameter values

There are several ways to simulate default parameters in Java:

1. Method overloading.

```java
void foo(String a, Integer b) {
    //...
}

void foo(String a) {
    foo(a, 0); // here, 0 is a default value for b
}

foo("a", 2);
foo("a");
```

One of the limitations of this approach is that it doesn't work if you
have two optional parameters of the same type and any of them can be
omitted.

2. Varargs.

a) All optional parameters are of the same type:

```java
void foo(String a, Integer... b) {
    Integer b1 = b.length > 0 ? b[0] : 0;
    Integer b2 = b.length > 1 ? b[1] : 0;
    //...
}

foo("a");
foo("a", 1, 2);
```

b) Types of optional parameters may be different:

```java
void foo(String a, Object... b) {
    Integer b1 = 0;
    String b2 = "";
    if (b.length > 0) {
      if (!(b[0] instanceof Integer)) {
          throw new IllegalArgumentException("...");
      }
      b1 = (Integer)b[0];
    }
    if (b.length > 1) {
        if (!(b[1] instanceof String)) {
            throw new IllegalArgumentException("...");
        }
        b2 = (String)b[1];
        //...
    }
    //...
}

foo("a");
foo("a", 1);
foo("a", 1, "b2");
```

The main drawback of this approach is that if optional parameters are of
different types you lose static type checking. Furthermore, if each
parameter has different meaning you need some way to distinguish them.


3. Nulls. To address the limitations of the previous approaches you can
   allow null values and then analyse each parameter in a method body:

```java
void foo(String a, Integer b, Integer c) {
    b = b != null ? b : 0;
    c = c != null ? c : 0;
    //...
}

foo("a", null, 2);
```

Now all arguments values must be provided, but the default ones may be
null.

4. Optional class. This approach is similar to nulls, but uses guava
   Optional class for parameters that have a default value:

```java
void foo(String a, Optional<Integer> bOpt) {
    Integer b = bOpt.isPresent() ? bOpt.get() : 0;
    //...
}

foo("a", Optional.of(2));
foo("a", Optional.<Integer>absent());
```

Optional makes a method contract explicit for a caller, however, one may
find such signature too verbose.

5. Builder pattern. The builder pattern is used for constructors and is
   implemented by introducing a separate Builder class:

```java
 class Foo {
     private final String a;
     private final Integer b;

     Foo(String a, Integer b) {
       this.a = a;
       this.b = b;
     }

     //...
 }

 class FooBuilder {
   private String a = "";
   private Integer b = 0;

   FooBuilder setA(String a) {
     this.a = a;
     return this;
   }

   FooBuilder setB(Integer b) {
     this.b = b;
     return this;
   }

   Foo build() {
     return new Foo(a, b);
   }
 }

 Foo foo = new FooBuilder().setA("a").build();
```

6. Maps. When the number of parameters is too large and for most of them
   default values are usually used, you can pass method arguments as a
   map of their names/values:

```java
void foo(Map<String, Object> parameters) {
    String a = "";
    Integer b = 0;
    if (parameters.containsKey("a")) {
        if (!(parameters.get("a") instanceof Integer)) {
            throw new IllegalArgumentException("...");
        }
        a = (String)parameters.get("a");
    }
    if (parameters.containsKey("b")) {
        //...
    }
    //...
}

foo(ImmutableMap.<String, Object>of(
    "a", "a",
    "b", 2,
    "d", "value"));
```

Please note that you can combine any of these approaches to achieve a
desirable result.


## String format

- https://www.baeldung.com/java-string-performance
    + String performance
- https://dzone.com/articles/java-string-formatting
- Use `MessageFormat` for simple formatting (most of the cases) because
  it's easiest to use
- Use `String.format` for VERY complex formatting
    + This has a lot of configuration to achieve your formatting
    + https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax
- `+` and `StringBuilder` are the fastest (`+` compiled to
  `StringBuilder`)

## Routing data from OutputStream to InputStream

- https://blog.ostermiller.org/convert-a-java-outputstream-to-an-inputstream/
- https://stackoverflow.com/questions/1225909/most-efficient-way-to-create-inputstream-from-outputstream
- https://stackoverflow.com/questions/5778658/how-to-convert-outputstream-to-inputstream
- https://www.geeksforgeeks.org/java-io-input-output-in-java-with-examples/


## Void vs void

- https://stackoverflow.com/questions/10839042/what-is-the-difference-between-java-lang-void-and-void/
- `Void` is used in Generics

## Private static methods

- https://softwareengineering.stackexchange.com/questions/234412/why-have-private-static-methods
- A fairly common reason (in Java) would be for initializing immutable
  field variables in a constructor by using a simple private static
  method to reduce constructor clutter.
- A common use-case for a private static method is a utility method
  which is
    + only used by that one class
    + is independent of the internal state of that class


## Useful libraries

- [Apache Commons][apache-common] project
- Google Guava
- Lombok
- Fastutil
    + https://www.baeldung.com/fastutil
- MapStruct
    + https://www.baeldung.com/mapstruct
    + https://mapstruct.org/

## Working with time, timezone

- Using `java.time` APIs after Java SE 8
- https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/package-summary.html
- Java Zone Id list
    + https://stackoverflow.com/questions/42512290/where-is-the-official-list-of-zone-names-for-java-time
    + https://en.wikipedia.org/wiki/List_of_tz_database_time_zones

## Redirection of Input and Output

The command line interface of the operating system provides a way to
link a file to the input of a program, as if all the characters in the
file had actually been typed by a user.
- `java SentinelDemo < numbers.txt`
- Redirect output: `java SentinelDemo < numbers.txt > output.txt`

## Input Validation

```java
if  (in.hasNextInt())
{
    int floor = in.nextInt();
    // Process the input value
}
else
{
    System.out.println("Error: Not an integer.")
}
```

## Logging

- Sanitize / encode the input before logging
    + https://www.mend.io/resources/blog/best-practices-for-dealing-with-log4j/
    + https://www.baeldung.com/jvm-log-forging
    + https://github.com/OWASP/owasp-java-encoder
    + Or upgrade to a newer version without the bugs
- Log4J2: the most popular logging framework for Java

Instead of using `System.out.println` to print out trace messages, use
the global logger object.

```java
Logger.getGlobal().info("status is SINGLE");
```

By default, the message is printed. But if you call `Logger.getGlobal
().setLevel(Level.OFF);` at the beginning of the main method of your
program, all log message printing is suppressed. Set the level to
Level.INFO to turn logging of info messages on again.

- Log levels
    + `ALL < TRACE < DEBUG < INFO < WARN < ERROR < FATAL < OFF`
    + You can call `setLevel(Level.xxxx)` to control how much log you
      want to see. `ALL` will turn all logs on, and a ton of logs for
      you to inspect. `OFF` will disable all logs.
    + In your code, you want a variety of different log levels, so when
      you change the configuration later, you can see different detail
      levels.
    + https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels


## Comparing Floating-Point Numbers, Strings, Objects

```java
final double EPSILON = 1E-14;
if (Math.abs(x-y) <= EPSILON)
{
    // x is approximately equal to y
}
```

```java
if (strin1.equals(string2))
{
    // ...
}
```

`string1.compareTo(string2)`: comparing strings using lexicographic
order.

`==`: compare the references refer to the objects

## [Send mail](https://cloud.google.com/appengine/docs/java/mail/usingjavamail)

## Convert int to String

- String.valueOf(number)
- Integer.toString(number) : check null before
- Concat string: "" + number

## Decompile Java class files, jar files

### Available decompilers - Listing follow popular

1. [Procyon](https://bitbucket.org/mstrobel/procyon): 2014. JDK 5,
   partly 6. Written in Java. Worth trying.

2. CFR - 2014. JDK 6, 7, 8 support. Written in Java 6.

“CFR by Lee Benfield is well on its way to becoming the premier Java
Decompiler. Lee and I actually work for the same company and share
regression tests. We're engaged in a friendly competition to see who can
deliver a better decompiler. Based on his progress thus far, there's a
very good chance he will win--at least on decompiling obfuscated code
:)”

3. Candle - 2013. Written in Java. By Brad Davis @ RH. “only decompiles
   a subset of the JVM operations”.

4. Krakatau - 2014.  JDK 7 support? Written in Python.

“Includes a robust verifier. Focuses on translating arbitrary bytecode
into valid Java code, as opposed to reconstructing the original code.”

5. JBVD - 2013. Academic Free License (AFL). Javassist approach. Unknown
   quality.

6. EDJC - 2011. Written in Java.

7. JD - JD-Core and JD-GUI are written in C++.

### GUI Front Ends Interface base on these decompilers

[Jadx](https://github.com/skylot/jadx)

[Luyten](https://github.com/deathmarine/Luyten)

[Bytecode Viewer](https://github.com/Konloch/bytecode-viewer)

## Compare jar file content with source code

1. You export source code into jar file. (e.g: use Eclipse to export)
2. Use decompiler jar file tool to decompile two jar file into source code. (e.g: luyten, jadx, etc.)
3. Use compare tool to compare content of two source code folder is generated by step 2. (e.g: Beyond Compare tool)

# Troubleshooting

## java.lang.NoSuchMethodError: org.apache.commons.collections.CollectionUtils.size(Ljava/lang/Object;)

- Usually these types of problems occur when there are two versions of
  org.apache.commons.collections.CollectionUtils on the classpath, a
  newer one with the method and an older one without, and the
  classloader non-deterministically loads the old one.

# References

[wiki]: https://en.wikipedia.org/wiki/Java_(programming_language)
[java-guidelines-iwombat]: http://iwombat.com/standards/JavaStyleGuide.html
[apache-common]: https://commons.apache.org/
[apache-log4j2]: https://logging.apache.org/log4j/2.x/
