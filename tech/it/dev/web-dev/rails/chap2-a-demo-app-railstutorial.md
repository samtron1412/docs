## Chapter 2 - A demo app
The purpose is to get a **high-level overview of Ruby on Rails programming** (and web development in general) by rapidly generating an application using **scaffold** generators.

The resulting demo app will allow us to **interact with it through its URLs**, giving us insight into the structure of a Rails application, including a first example of the **REST architecture favored by Rails**.

The demo app will consist of **users** and their associated **microposts**.

### 2.1 - Planning the application
We’ll start by generating the application skeleton using the rails command:

	$ cd ~/rails_projects
	$ rails new demo_app
	$ cd demo_app

Next, we’ll use a text editor to update the **Gemfile**:

	source 'https://rubygems.org'
	ruby '2.0.0'
	#ruby-gemset=railstutorial_rails_4_0

	gem 'rails', '4.0.8'

	group :development do
	  gem 'sqlite3', '1.3.8'
	end

	gem 'sass-rails', '4.0.1'
	gem 'uglifier', '2.1.1'
	gem 'coffee-rails', '4.0.1'
	gem 'jquery-rails', '3.0.4'
	gem 'turbolinks', '1.1.1'
	gem 'jbuilder', '1.0.2'

	group :doc do
	  gem 'sdoc', '0.3.20', require: false
	end

	group :production do
	  gem 'pg', '0.15.1'
	  gem 'rails_12factor', '0.0.2'
	end

Update the Gemfile.lock:

	$ bundle install --without production
	$ bundle update
	$ bundle install

(Recall that if Bundler complains about a readline error, try adding gem ’rb-readline’ to your Gemfile.)

Finally, we’ll put the demo app under version control. Update `.gitignore` file

	# See https://help.github.com/articles/ignoring-files for more about ignoring files.
	#
	# If you find yourself ignoring temporary files generated by your text editor
	# or operating system, you probably want to add a global ignore instead:
	#   git config --global core.excludesfile '~/.gitignore_global'

	# Ignore bundler config.
	/.bundle

	# Ignore the default SQLite database.
	/db/*.sqlite3
	/db/*.sqlite3-journal

	# Ignore all logfiles and tempfiles.
	/log/*.log
	/tmp

	# Ignore other unneeded files.
	database.yml
	doc/
	*.swp
	*~
	.project
	.DS_Store
	.idea
	.secret

Create git:

	$ git init
	$ git add .
	$ git commit -m "Initial commit"

Push it up to GitHub:

	$ git remote add origin https://github.com/<username>/demo_app.git
	$ git push -u origin master

**Users**: id, name, email

**microposts**: id, content, user_id### 2.1 - Planning the application

### 2.2 - The Users resource
The combination will constitute a **Users resource**, which will allow us to think of users as objects that can be *created, read, updated, and deleted* through the web via the HTTP protocol.

Rails scaffolding is generated by passing the **scaffold** command to the **rails generate** script. The argument of the scaffold command is the *singular version of the resource name* (in this case, User), together with optional parameters for the data model’s attributes:

	$ rails generate scaffold User name:string email:string

By including **name:string** and **email:string**, we have arranged for the User model to have the form we designed before. (Note that there is no need to include a parameter for **id**; it is created automatically by Rails for use as the primary key in the database.)

To proceed with the demo application, we first need to **migrate** the database using *Rake*:

	$ bundle exec rake db:migrate

This simply updates the database with our new users data model. Note that, in order to ensure that the command uses the version of Rake corresponding to our Gemfile, we need to run **rake** using **bundle exec**.

With that, we can run the local web server using **rails s**:

	$ rails s

Now the demo application should be ready to go at [http://localhost:3000/](http://localhost:3000/).

#### 2.2.1 - A user tour
URL |	Action |	Purpose
-|-|-
/users |	index |	page to list all users
/users/1 |	show |	page to show user with id 1
/users/new |	new |	page to make a new user
/users/1/edit |	edit |	page to edit user with id 1

#### 2.2.2 - MVC in action
<figure>
  <figcaption style="text-align:center;">MVC in action</figcaption>
  <hr style="width:70%;margin-left:auto;margin-right:auto;" />
  <img align="middle" src="railsFigures/mvc_detailed.png" alt="MVC" title="MVC">
</figure>

1. The browser issues a request for the **/users** URL.
2. Rails routes /users to the **index** action in the Users controller.
3. The **index** action asks the User model to retrieve all users (**User.all**).
4. The User model pulls all the users from the database.
5. The User model returns the list of users to the controller.
6. The controller captures the users in the **@users** variable, which is passed to the **index** view.
7. The view uses embedded Ruby to render the page as HTML.
8. The controller passes the HTML back to the browser.

Note the notation **class UsersController < ApplicationController;** this is an example of a Ruby class with *inheritance*. The Users controller in schematic form.

	class UsersController < ApplicationController
	.
	.
	.

	  def index
	    .
	    .
	    .
	  end

	  def show
	    .
	    .
	    .
	  end

	  def new
	    .
	    .
	    .
	  end

	  def create
	    .
	    .
	    .
	  end

	  def edit
	    .
	    .
	    .
	  end

	  def update
	    .
	    .
	    .
	  end

	  def destroy
	    .
	    .
	    .
	  end
	end

You may notice that there are *more actions than there are pages*; the **index**, **show**, **new**, and **edit** actions all correspond to pages, but there are additional **create**, **update**, and **destroy** actions as well. These actions *don’t typically render pages* (although they sometimes do); instead, their main purpose is to *modify information about users in the database*. This full suite of controller actions, represents the implementation of the **REST** architecture in Rails, which is based on the ideas of *representational state transfer* identified and named by computer scientist [Roy Fielding](http://en.wikipedia.org/wiki/Roy_Fielding). Note that there is some overlap in the URLs; for example, both the user **show** action and the **update** action correspond to the URL **/users/1**. The difference between them is the [HTTP request method](http://en.wikipedia.org/wiki/HTTP_request#Request_methods) they respond to.

HTTP request |	URL |	Action |	Purpose
-|-|-|-
GET |	/users |	index |	page to list all users
GET |	/users/1 |	show |	page to show user with id 1
GET |	/users/new |	new |	page to make a new user
POST |	/users |	create |	create a new user
GET	| /users/1/edit |	edit |	page to edit user with id 1
PATCH	| /users/1 |	update |	update user with id 1
DELETE	| /users/1 |	destroy |	delete user with id 1

Although REST theory is rather abstract, in the context of Rails applications REST means that most application components (such as users and microposts) are *modeled as resources* that can be created, read, updated, and deleted—operations that correspond both to the [CRUD operations of relational databases](http://en.wikipedia.org/wiki/Create,_read,_update_and_delete) and four fundamental [HTTP request methods](http://en.wikipedia.org/wiki/HTTP_request#Request_methods): POST, GET, PATCH, and DELETE.

As a Rails application developer, the RESTful style of development *helps you make choices about which controllers and actions to write*: you simply structure the application using resources that get created, read, updated, and deleted.

#### 2.2.3 - Weakness of this Users resource
Though good for getting a general overview of Rails, the scaffold Users resource suffers from a number of severe weaknesses:
- **No data validations**. Our User model accepts data such as blank names and invalid email addresses without complaint.
- **No authentication**. We have no notion of signing in or out, and no way to prevent any user from performing any operation.
- **No tests**. This isn’t technically true—the scaffolding includes rudimentary tests—but the generated tests are ugly and inflexible, and they don’t test for data validation, authentication, or any other custom requirements.
- **No layout**. There is no consistent site styling or navigation.
- **No real understanding**. If you understand the scaffold code, you probably shouldn’t be reading this book.

### 2.3 The Microposts resource
Throughout this section, I recommend comparing the elements of the Microposts resource with the analogous user elements. The RESTful structure of Rails applications is best absorbed by this sort of repetition of form; indeed, seeing the parallel structure of Users and Microposts even at this early stage is one of the prime motivations for this chapter.

#### 2.3.1 - A micropost microtour
As with the Users resource, we’ll generate scaffold code for the Microposts resource using **rails generate scaffold**:

	$ rails generate scaffold Micropost content:string user_id:integer

To update our database with the new data model, we need to run a migration:

	$ bundle exec rake db:migrate

#### 2.3.2 - Putting the *micro* to microposts
Any micropost worthy of the name should have some means of *enforcing the length of the post*. Implementing this **constraint** in Rails is easy with **validations**; to accept microposts with at most 140 characters, we use a *length* validation. At this point, you should open the file **app/models/micropost.rb** in your text editor or IDE and fill it with the contents:

	class Micropost < ActiveRecord::Base
	  validates :content, length: { maximum: 140 }
	end

#### 2.3.3 - A user has_many microposts
One of the most powerful features of Rails is the ability to form **associations**(relationship) between different data models. In the case of our User model, each user potentially has many microposts. We can express this in code by updating the User and Micropost models:

user.rb

	class User < ActiveRecord::Base
	  has_many :microposts
	end

micropost.rb

	class Micropost < ActiveRecord::Base
	  belongs_to :user
	  validates :content, length: { maximum: 140 }
	end

In [Chapter 10](#chapter-10-user-microposts) and [Chapter 11](#chapter-11-following-users), we will use the association of users and microposts both to display all of a user’s microposts and to construct a Twitter-like micropost feed. For now, we can examine the implications of the user-micropost association by using the **console**, which is a useful tool for interacting with Rails applications. We first invoke the console with **rails console** at the command line, and then retrieve the first user from the database using **User.first** (putting the results in the variable first_user)

	$ rails console
	>> first_user = User.first
	=> #<User id: 1, name: "Michael Hartl", email: "michael@example.org",
	created_at: "2013-03-06 02:01:31", updated_at: "2013-03-06 02:01:31">
	>> first_user.microposts
	=> [#<Micropost id: 1, content: "First micropost!", user_id: 1, created_at:
	"2013-03-06 02:37:37", updated_at: "2013-03-06 02:37:37">, #<Micropost id: 2,
	content: "Second micropost", user_id: 1, created_at: "2013-03-06 02:38:54",
	updated_at: "2013-03-06 02:38:54">]
	>> exit

#### 2.3.4 - Inheritance hierarchies
We end our discussion of the demo application with a brief description of the *controller and model class hierarchies* in Rails.

We start with the inheritance structure for models. Both the User model and the Micropost model inherit (via the left angle bracket **<**) from **ActiveRecord::Base**, which is the base class for models provided by **ActiveRecord**; It is by inheriting from **ActiveRecord::Base** that our model objects gain the ability to *communicate with the database*, *treat the database columns as Ruby attributes*, and so on.

The inheritance structure for controllers is only slightly more complicated. Both the Users controller and the Microposts controller inherit from the **ApplicationController**. **ApplicationController** itself inherits from **ActionController::Base**; this is the base class for controllers provided by the Rails library **Action Pack**.

As with model inheritance, by inheriting ultimately from **ActionController::Base** both the Users and Microposts controllers gain a large amount of functionality, such as the *ability to manipulate model objects*, *filter inbound HTTP requests*, and *render views as HTML*. Since all Rails controllers inherit from **ApplicationController**, *rules defined in the Application controller automatically apply to every action in the application*. For example, in Section 8.2.1 we’ll see how to include helpers for signing in and signing out of all of the sample application’s controllers.

#### 2.3.5 - Deploying the demo app
With the completion of the Microposts resource, now is a good time to push the repository up to GitHub:

	$ git add .
	$ git commit -m "Finish demo app"
	$ git push

At this point, you can also deploy the demo app to Heroku:

	$ heroku create
	$ git push heroku master

Some readers have reported needing to precompile static assets (such as CSS and images), which can be included by hand as follows:

    # This should only be used if your Heroku deploy fails without it.
	$ rake assets:precompile
	$ git add .
	$ git commit -m "Add precompiled assets for Heroku"
	$ git push heroku master

To get the application’s database to work, you’ll also have to migrate the production database:

	$ heroku run rake db:migrate

### 2.4 - Conclusion
#### Strengths

- High-level overview of Rails
- Introduction to MVC
- First taste of the REST architecture
- Beginning data modeling
- A live, database-backed web application in production

#### Weaknesses

- No custom layout or styling
- No static pages (like “Home” or “About”)
- No user passwords
- No user images
- No signing in
- No security
- No automatic user/micropost association
- No notion of “following” or “followed”
- No micropost feed
- No test-driven development
- No real understanding
