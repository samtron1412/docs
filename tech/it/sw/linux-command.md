[TOC]

# Common Tools

- https://www.linuxtrainingacademy.com/linux-commands-cheat-sheet/
- https://www.temok.com/blog/400-linux-basic-commands-you-should-know/
- Packages that contain the following tools
    + `procps` package: command line and utilities for browsing procfs
      (a "pseudo" file system dynamically generated by the kernel to
      provide information about the status of entries in its process
      table)
        * https://gitlab.com/procps-ng/procps
        * free, hugetop, kill, pgrep, pkill, pmap, ps, pwdx, skill,
          slabtop, snice, sysctl, tload, top, uptime, vmstat, w, watch
    + `net-tools` package: networking utilities
        * https://net-tools.sourceforge.io/
        * arp, hostname, ifconfig, ipmaddr, iptunnel, mii-tool, nameif,
          netstat, plipconfig, rarp, route, slattach
    + `curl` package: https://curl.se/
    + Usually other commands has the packages with the same name such as
      `file` package for `file` command.


1. `ls` - The most frequently used command in Linux to list directories
1. `pwd` - Print working directory command in Linux
1. `cd` - Linux command to navigate through directories
1. `mkdir` - Command used to create directories in Linux
1. `mv` - Move or rename files in Linux
1. `cp` - Similar usage as mv but for copying files in Linux
1. `rm` - Delete files or directories
1. `touch` - Create blank/empty files
1. `ln` - Create symbolic links (shortcuts) to other files
1. `cat` - Display file contents on the terminal
1. `clear` - Clear the terminal display
1. `echo` - Print any text that follows the command
1. `less` - Linux command to display paged outputs in the terminal
1. `man` - Access manual pages for all Linux commands
1. `uname` - Linux command to get basic information about the OS
1. `whoami` - Get the active username
1. `tar` - Command to extract and compress files in Linux
1. `grep` - Search for a string within an output
1. `head` - Return the specified number of lines from the top
1. `tail` - Return the specified number of lines from the bottom
1. `diff` - Find the difference between two files
1. `cmp` - Allows you to check if two files are identical
1. `comm` - Combines the functionality of diff and cmp
1. `sort` - Linux command to sort the content of a file while outputting
1. `export` - Export environment variables in Linux
1. `zip` - Zip files in Linux
1. `unzip` - Unzip files in Linux
1. `ssh` - Secure Shell command in Linux
1. `service` - Linux command to start and stop services
1. `ps` - Display active processes
1. `kill` and `killall` - Kill active processes by process ID or name
1. `df` - Display disk filesystem information
1. `mount` - Mount file systems in Linux
1. `chmod` - Command to change file permissions
1. `chown` - Command for granting ownership of files or folders
1. `ifconfig` - Display network interfaces and IP addresses
1. `traceroute` - Trace all the network hops to reach the destination
1. `wget` - Direct download files from the internet
1. `ufw` - Firewall command
1. `iptables` - Base firewall for all other firewall utilities to interface with
1. `apt, pacman, yum, rpm` - Package managers depending on the distro
1. `sudo` - Command to escalate privileges in Linux
1. `cal` - View a command-line calendar
1. `alias` - Create custom shortcuts for your regularly used commands
1. `dd` - Majorly used for creating bootable USB sticks
1. `whereis` - Locate the binary, source, and manual pages for a command
1. `whatis` - Find what a command is used for
1. `top` - View active processes live with their system usage
1. `useradd` and `usermod` - Add new user or change existing users data
1. `passwd` - Create or update passwords for existing users
1. `nohup` - no hang up, a command that keep processes running even
   after exiting the shell or terminal. It prevents the processes from
   receiving the SIGHUP (Signal Hang UP) signal.
    + https://www.digitalocean.com/community/tutorials/nohup-command-in-linux
1. `realpath` - Print the resolved path
    + `realpath <file/folder name>`

# bash
GNU Bourne-Again SHell

`bash -c <string>` : execute command from string.

# echo - prints arguments separated by a space and terminated by a newline
>You should avoid it.

Two main branches of Unix: AT&T's System V and BSD. One of their differences was the behavior of `echo`. Built into all modern shells, `echo` prints its arguments with a single space between them to the standard output stream, followed by a newline:

	$ echo The   quick  brown   fox
	The quick brown fox

The default newline can be suppressed in one of two ways, depending on the shell:

	$ echo -n No newline
	No newline$ echo "No newline\c"
	No newline$



## Check exit status code

	run command
	echo $?



# man - display information about a command
# cd - change directories
# ls - list the contents of a directory
`ls -d */` : list all subdirectories in the current directory

ll – list at long mode

List files sorted by the time they were last modified:
`ls -lt`

List files human readable
`ls -lh`

List files order by size
`ls -lS` and with human readable `ls -lhS`

# pwd - show the path to the current directory
# cp - copy a file to another file or directory

# scp – secure copy , remote file copy

# mv - move or rename a file

- Rename multiple files
    + `for i in *; do mv $i $i.gz ; done`

# rm - remove a file
# mkdir - create a directory
# chmod - change the permissions on a file
# less - view the contents of a file
# nano - file editor

# netstat
`netstat -tunap | grep :80` : find what process use 80 port. (-t: tcp, -u: udp, -n: numeric ip instead hostname, -a: all, -p: program/process id)

# date - display the current date and time
# passwd - Change your login password

# du - display the space size used for a directory

- Show size of current directory:
    + `du -sh` - s: summary, h: human readable
- Show size of `dir1` directory
    + `du -sh dir1`
- Shows the size of the files and directories ordered by size.
    + `du -sk * | sort -rn`

# df - finding the disk free space / disk usage

- Displays a list of mounted partitions.
    + `df -h`

# links - text based web browser - hay
# w - See who else is logged in
    - tty – native terminal of host
    - pty/pts – remote terminal, ie# Ssh, xterm…

# Text Processing Tools

- Thinking in term of grep, sed, and awk
    + https://arstechnica.com/gadgets/2021/08/linux-bsd-command-line-101-using-awk-sed-and-grep-in-the-terminal/
    + The case of Donald Knuth and Doug Mcilroy
        * https://sci-hub.se/https://dl.acm.org/doi/10.1145/5948.315654
- https://www.baeldung.com/linux/grep-sed-awk-differences
- Introduction
    + https://www-users.york.ac.uk/~mijp1/teaching/2nd_year_Comp_Lab/guides/grep_awk_sed.pdf
- When it comes to text processing in Linux, the three tools that come
  in pretty handy are grep, sed, and awk. Although being totally
  different tools, their functionality seems to overlap in simple
  scenarios.
    + For example, to find a pattern in a file and print the matches to
      the standard output, we’ll find that all of them can do that.
- However, if we stretch beyond this simple exercise, we’ll find that
  `grep is only good for simple text matching and printing`.
- On the other hand, in addition to match and print text, `sed offers
  additional text transformation commands like substitution`.
- Finally, awk, being the most powerful of these tools, is `a scripting
  language that offers a multitude of features that do not exists in the
  former two`.

## grep

## sed

- http://www.thegeekstuff.com/2009/11/unix-sed-tutorial-append-insert-replace-and-count-file-lines/
- **sed** is a stream editor.
    + A stream editor is used to perform basic text transformations on
      an input stream (a file or input from a pipeline).
    + While in some ways similar to an editor which permits scripted
      edits (such as ed), sed works by making only one pass over the
      input(s), and is consequently more efficient. But it is sed's
      ability to filter text in a pipeline which particularly
      distinguishes it from other types of editors.

Append a line at the end of the file: `sed '$ a\sentence' filepath`

## awk



# find

Lệnh trên tìm tất cả các file có tên là “music” trong toàn bộ hệ thống

`find / –name music`

Tìm các file trong thư mục /home có owned là joe

`find /home -user joe`

Tìm các file trong thư mục /usr kết có tên kết thúc là “stat”

`find /usr -name *stat`

Tìm các file trong thư mục /var/spool đã được hiệu chỉnh trong vòng >60 ngày trước

`find /var/spool –mtime +60`

Tìm các file đã được hiệu chỉnh trong vòng 24h trở lại đây trong thư mục home
`find $HOME –mtime 0`

Tìm các file có tên “core” trong thư mục /tmp và xóa chúng đi
`find /tmp –name core –type f –print | xargs /bin/rm –f`

Tìm các file được chmod theo thông số nào đó
`find # –perm –664`

Tìm các file được cho phép đọc bởi tất cả mọi người nhưng không cho phép thực thi
`find # –perm –444 ! –perm /111`

# [useradd](http://www.tecmint.com/add-users-in-linux/)
## synopsis
`useradd [options] <username>`
`useradd -D <username>`
`useradd -D [options] <username>`

## description
create a new user or update default new user information

When invoked without the **-D** option, the useradd command creates a new user account using the values specified on the command plus the default values. And with **-D** option, values only on the command.

## options
`-d, --home-dir <HOME_DIR>`

    The new user will be created using HOME_DIR as the value for the user's login directory.

`-g, --gid <GROUP>`

    The group name or number of the user's initial login group. The group name must exist. A group number must refer to an already existing group.

# userdel
## synopsis
`userdel [options] <username>`

## description
delete a user account and related files

## options
`-f, --force`

    Remove user though user still logged in.

`-r, --remove`

    Remove home directory of user


# groupadd
Create a new group

## synopsis
`groupadd [options] group`

# groupdel
delete a group

`groupdel [options] <GROUP>`


# change color of shell
- https://wiki.archlinux.org/index.php/Color_Bash_Prompt
- http://askubuntu.com/questions/466198/how-do-i-change-the-color-for-directories-with-ls-in-the-console





# tail
real time log file view: `tail -f ca <file_path>`

# chkconfig
## Linux Runlevels explained

| Run level | Mode          | Action                   |
| -   | -             | -                        |
| 0   | Halt          | Shuts down system                    |
| 1   | Single-User Mode    | Does not configure network interfaces, start daemons, or allow non-root logins |
| 2   | Multi-User Mode     | Does not configure network intrefaces or start daemons.      |
| 3   | Multi-User Mode with Networking | Starts the system normally.                |
| 4   | Undefined           | Not used/User-definable              |
| 5   | X11           | as runlevel 3 + display manager            |
| 6   | Reboot        | Reboots the system                   |

The `chkconfig` tool is used in Red Hat based systems (like CentOS) to control what services are started at which runlevels. Running the command `chkconfig –list` will display a list of services whether they are enabled or disabled for each runlevel.

`chkconfig --level 234 tomcat on`


# unset
Remove a variable environment: `unset PATH`
`unset HOME`

# mount
- Listing currently mounted file systems: `mount`
- Listing currently mounted file system type specific: `mount -t <type>`
	+ `mount -t ext3`
- Mounting a file system: `mount [option...] <device> <directory>`
	+ `mount /dev/sdc1 /media/flashdisk`
	+ `mount -t vfat /dev/sdc1 /media/flashdisk`
- Unmounting a file system: `umount <directory/device>`
	+ Check whether file system is in use by any process: `fuser -m <directory>`
	+ Unmouting: `umount /media/cdrom`

# type - displays information about a command

# source a.k.a `.` (dot) - executes a script in the current shell environment

# printf - prints the arguments as specified by a format string
`$ printf '%s\n' "Hello World!"`

# chattr - change file attributes on a Linux file system

# [ln](http://www.computerhope.com/unix/uln.htm)
- `ln` cannot create hard links between partitions because the implement inode number of the file system. [source](http://www.cyberciti.biz/tips/why-isnt-it-possible-to-create-hard-links-across-file-system-boundaries.html)

# tar - "Tape ARchiver" an archiving utility
- Create tar.gz files: `$ tar pczf myarchive.tar.gz /path/to/directory`
	+ `p`: this option stand for "preserver", it instructs tar to store details on file owner and file permissions in the archive.
	+ `c`: Stands for create.
	+ `z`: Enable gzip compression
	+ `f`: The file option tells tar to create an archive file. Tar will send the output to stdout if this option is omitted.
	+ `# tar pczf /root/etc.tar.gz /etc`
	+ `$ tar pczf /backup/myuser.tar.gz /home/myuser`
- Extract tar.gz files: `tar xzf myarchive.tar.gz`
	+ `x` stand for extract, it is mandatory when a tar file shall be extracted.
- List the contents of tar.gz files: `tar ztvf myarchive.tar.gz`
- Create tbz2 files: `tar pjcf myarchive.tbz2`
- Extract tbz2 files: `tar jxf myarchive.tbz2`
- List the contents of tbz2: `tar jtvf myarchive.tbz2`

# tree

- Show tree up to X levels: `tree -L <X>`
